{"version":3,"file":"static/js/956.42a6d303.chunk.js","mappings":"0NAKMA,EAAc,IAAIC,EAAAA,KAClBC,EAAkB,IAAID,EAAAA,QACtBE,EAAW,SAAC,GAGZ,IAFJC,EAEI,EAFJA,OACGC,GACC,YACEC,EAAMC,EAAAA,OAAa,MACnBC,EAAYD,EAAAA,OAAa,MAmB/B,OAfAA,EAAAA,WAAgB,WACd,IAAIE,EAAcC,EAEkB,OAA/BD,EAAeH,EAAIK,UAAmE,OAA9CD,EAAsBD,EAAaG,SAAmBF,EAAoBE,SACrHJ,EAAUG,QAAUL,EAAIK,QAAQC,OAChCN,EAAIK,QAAQC,OAAOA,OAAOC,IAAIP,EAAIK,YAEnC,KACHG,EAAAA,EAAAA,IAAS,WACHN,EAAUG,UACZX,EAAYe,cAAcP,EAAUG,SACpCX,EAAYgB,QAAQd,GACpBI,EAAIK,QAAQM,SAASC,IAAIV,EAAUG,QAAQM,SAASE,EAAIjB,EAAgBiB,EAAIf,EAAO,GAAK,EAAGI,EAAUG,QAAQM,SAASG,EAAIlB,EAAgBkB,EAAIhB,EAAO,GAAK,EAAGI,EAAUG,QAAQM,SAASI,EAAInB,EAAgBmB,EAAIjB,EAAO,GAAK,OAG5MG,EAAAA,cAAoB,SAASe,EAAAA,EAAAA,GAAS,CACxDhB,IAAKA,GACJD,M,8EC7BCkB,EAAqB,IAAIC,EAAAA,QACzBC,EAAqB,IAAID,EAAAA,QACzBE,EAAqB,IAAIF,EAAAA,QAEzBG,EAAsB,IAAIC,EAAAA,QAC1BC,EAAsB,IAAID,EAAAA,QAC1BE,EAAsB,IAAIF,EAAAA,QAE1BG,EAAoC,IAAIP,EAAAA,QA2B9C,SAASQ,EAAiCC,EAAKhB,EAAUiB,EAAIC,EAAGC,EAAGC,EAAGC,GAErEf,EAAGgB,oBAAqBtB,EAAUkB,GAClCV,EAAGc,oBAAqBtB,EAAUmB,GAClCV,EAAGa,oBAAqBtB,EAAUoB,GAElC,IAAMG,EAhCP,SAA4BP,EAAKQ,EAAIC,EAAIC,EAAIC,EAAON,GAanD,OAAmB,QAVdA,IAASO,EAAAA,SAEDZ,EAAIa,kBAAmBH,EAAID,EAAID,GAAI,EAAMG,GAIzCX,EAAIa,kBAAmBL,EAAIC,EAAIC,EAAIL,IAASS,EAAAA,WAAYH,IAIpC,KAI1B,CAENI,SAJgBf,EAAIgB,OAAOC,WAAYN,GAKvCA,MAAOA,EAAMO,SAYOC,CAAmBnB,EAAKV,EAAIE,EAAIC,EAAIK,EAAmBO,GAE5E,GAAKE,EAAe,CAEdN,IAEJP,EAAIY,oBAAqBL,EAAIC,GAC7BN,EAAIU,oBAAqBL,EAAIE,GAC7BN,EAAIS,oBAAqBL,EAAIG,GAE7BG,EAAaN,GAAKmB,EAAAA,SAAAA,MAAgBtB,EAAmBR,EAAIE,EAAIC,EAAIC,EAAKE,EAAKC,EAAK,IAAIF,EAAAA,UAIrF,IAAM0B,EAAO,CACZnB,EAAGA,EACHC,EAAGA,EACHC,EAAGA,EACHkB,OAAQ,IAAI/B,EAAAA,QACZgC,cAAe,GAGhBH,EAAAA,SAAAA,UAAoB9B,EAAIE,EAAIC,EAAI4B,EAAKC,QAErCf,EAAac,KAAOA,EACpBd,EAAaiB,UAAYtB,EAI1B,OAAOK,EAKR,SAASkB,EAAcC,EAAKrB,EAAML,EAAK2B,EAAKC,GAE3C,IAAMC,EAAkB,EAANF,EACZzB,EAAIwB,EAAII,MAAMC,KAAMF,GACpB1B,EAAIuB,EAAII,MAAMC,KAAMF,EAAY,GAChCzB,EAAIsB,EAAII,MAAMC,KAAMF,EAAY,GAEhCtB,EAAeR,EAAiCC,EAAK0B,EAAIM,WAAWhD,SAAU0C,EAAIM,WAAW/B,GAAIC,EAAGC,EAAGC,EAAGC,GAEhH,OAAKE,GAEJA,EAAaiB,UAAYG,EACpBC,GAAgBA,EAAcK,KAAM1B,GAClCA,GAID,KC9DD,SAAS2B,EAAyBC,EAAKC,EAAQC,GAErD,OAAa,OAARF,EAEG,MAIRA,EAAIxB,MAAM2B,aAAcF,EAAOG,aAC/BJ,EAAIpB,SAAWoB,EAAIxB,MAAMM,WAAYoB,EAAUrC,IAAIgB,QACnDmB,EAAIC,OAASA,EAERD,EAAIpB,SAAWsB,EAAUG,MAAQL,EAAIpB,SAAWsB,EAAUI,IAEvD,KAIAN,G,sDCtCIO,EAA0B,KAK1BC,EAAiB,GACjBC,EAAmB,MAInBC,EAAkBC,KAAKC,IAAK,GAAK,I,UCxBjCC,GAAb,QAEC,cAAc,kBCFR,SAASC,EAAYC,EAAaC,EAAOC,GAU/C,OARAA,EAAOC,IAAInE,EAAIiE,EAAOD,GACtBE,EAAOC,IAAIlE,EAAIgE,EAAOD,EAAc,GACpCE,EAAOC,IAAIjE,EAAI+D,EAAOD,EAAc,GAEpCE,EAAOE,IAAIpE,EAAIiE,EAAOD,EAAc,GACpCE,EAAOE,IAAInE,EAAIgE,EAAOD,EAAc,GACpCE,EAAOE,IAAIlE,EAAI+D,EAAOD,EAAc,GAE7BE,EAID,SAASG,EAAqBC,GAKpC,IAHA,IAAIC,GAAgB,EAChBC,GAAcC,IAERC,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAMC,EAAOL,EAAQI,EAAI,GAAMJ,EAAQI,GAClCC,EAAOH,IAEXA,EAAYG,EACZJ,EAAcG,GAMhB,OAAOH,EAKD,SAASK,EAAYC,EAAQX,GAEnCA,EAAOnE,IAAK8E,GAKN,SAASC,EAAa9D,EAAGC,EAAGiD,GAGlC,IADA,IAAIa,EAAMC,EACAC,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAMC,EAAKD,EAAI,EAGfF,EAAO/D,EAAGiE,GACVD,EAAO/D,EAAGgE,GACVf,EAAQe,GAAMF,EAAOC,EAAOD,EAAOC,EAGnCD,EAAO/D,EAAGkE,GACVF,EAAO/D,EAAGiE,GACVhB,EAAQgB,GAAOH,EAAOC,EAAOD,EAAOC,GAO/B,SAASG,EAAwBC,EAAYC,EAAgBf,GAEnE,IAAM,IAAIW,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAMK,EAAUD,EAAgBD,EAAa,EAAIH,GAC3CM,EAAQF,EAAgBD,EAAa,EAAIH,EAAI,GAE7CO,EAAOF,EAAUC,EACjBE,EAAOH,EAAUC,EAElBC,EAAOlB,EAAQW,KAEnBX,EAAQW,GAAMO,GAIVC,EAAOnB,EAAQW,EAAI,KAEvBX,EAAQW,EAAI,GAAMQ,IASd,SAASC,EAAoBpB,GAEnC,IAAMqB,EAAKrB,EAAQ,GAAMA,EAAQ,GAC3BsB,EAAKtB,EAAQ,GAAMA,EAAQ,GAC3BuB,EAAKvB,EAAQ,GAAMA,EAAQ,GAEjC,OAAO,GAAMqB,EAAKC,EAAKA,EAAKC,EAAKA,EAAKF,GCjBvC,SAASG,EAAWT,EAAgBU,EAAQC,EAAO9B,GAiBlD,IAjBkF,IAAxB+B,EAAwB,uDAAP,KAEvEC,EAAOzB,IACP0B,EAAO1B,IACP2B,EAAO3B,IACP4B,GAAS5B,IACT6B,GAAS7B,IACT8B,GAAS9B,IAET+B,EAAQ/B,IACRgC,EAAQhC,IACRiC,EAAQjC,IACRkC,GAAUlC,IACVmC,GAAUnC,IACVoC,GAAUpC,IAERqC,EAAqC,OAAnBb,EACdvB,EAAa,EAATqB,EAAYgB,EAA2B,GAAnBhB,EAASC,GAAatB,EAAIqC,EAAKrC,GAAK,EAAI,CAEzE,IAAMsC,EAAK3B,EAAgBX,EAAI,GACzBuC,EAAK5B,EAAgBX,EAAI,GACzBwC,EAAKF,EAAKC,EACVE,EAAKH,EAAKC,EACXC,EAAKhB,IAAOA,EAAOgB,GACnBC,EAAKd,IAAOA,EAAOc,GACnBL,GAAmBE,EAAKR,IAAQA,EAAQQ,GACxCF,GAAmBE,EAAKL,IAAQA,EAAQK,GAE7C,IAAMI,EAAK/B,EAAgBX,EAAI,GACzB2C,EAAKhC,EAAgBX,EAAI,GACzB4C,EAAKF,EAAKC,EACVE,EAAKH,EAAKC,EACXC,EAAKnB,IAAOA,EAAOmB,GACnBC,EAAKjB,IAAOA,EAAOiB,GACnBT,GAAmBM,EAAKX,IAAQA,EAAQW,GACxCN,GAAmBM,EAAKR,IAAQA,EAAQQ,GAE7C,IAAMI,EAAKnC,EAAgBX,EAAI,GACzB+C,EAAKpC,EAAgBX,EAAI,GACzBgD,EAAKF,EAAKC,EACVE,EAAKH,EAAKC,EACXC,EAAKtB,IAAOA,EAAOsB,GACnBC,EAAKpB,IAAOA,EAAOoB,GACnBb,GAAmBU,EAAKd,IAAQA,EAAQc,GACxCV,GAAmBU,EAAKX,IAAQA,EAAQW,GAI9CtD,EAAQ,GAAMgC,EACdhC,EAAQ,GAAMiC,EACdjC,EAAQ,GAAMkC,EAEdlC,EAAQ,GAAMmC,EACdnC,EAAQ,GAAMoC,EACdpC,EAAQ,GAAMqC,EAETO,IAEJb,EAAgB,GAAMO,EACtBP,EAAgB,GAAMQ,EACtBR,EAAgB,GAAMS,EAEtBT,EAAgB,GAAMU,EACtBV,EAAgB,GAAMW,EACtBX,EAAgB,GAAMY,GA8CxB,SAASe,EAAWhF,EAAOyC,EAAgBU,EAAQC,EAAO6B,GAQzD,IANA,IAAIC,EAAO/B,EACPgC,EAAQhC,EAASC,EAAQ,EACvBgC,EAAMH,EAAMG,IACZC,EAA0B,EAAbJ,EAAMK,OAGV,CAEd,KAAQJ,GAAQC,GAAS1C,EAAuB,EAAPyC,EAAWG,GAAeD,GAElEF,IAMD,KAAQA,GAAQC,GAAS1C,EAAwB,EAAR0C,EAAYE,IAAgBD,GAEpED,IAID,KAAKD,EAAOC,GA2BX,OAAOD,EArBP,IAAM,IAAIpD,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAIyD,EAAKvF,EAAc,EAAPkF,EAAWpD,GAC3B9B,EAAc,EAAPkF,EAAWpD,GAAM9B,EAAe,EAARmF,EAAYrD,GAC3C9B,EAAe,EAARmF,EAAYrD,GAAMyD,EAEzB,IAAIC,EAAK/C,EAAuB,EAAPyC,EAAe,EAAJpD,EAAQ,GAC5CW,EAAuB,EAAPyC,EAAe,EAAJpD,EAAQ,GAAMW,EAAwB,EAAR0C,EAAgB,EAAJrD,EAAQ,GAC7EW,EAAwB,EAAR0C,EAAgB,EAAJrD,EAAQ,GAAM0D,EAE1C,IAAIC,EAAKhD,EAAuB,EAAPyC,EAAe,EAAJpD,EAAQ,GAC5CW,EAAuB,EAAPyC,EAAe,EAAJpD,EAAQ,GAAMW,EAAwB,EAAR0C,EAAgB,EAAJrD,EAAQ,GAC7EW,EAAwB,EAAR0C,EAAgB,EAAJrD,EAAQ,GAAM2D,EAI3CP,IACAC,KAYH,IAAMO,EAAY,GACZC,EAAW,SAAEvH,EAAGC,GAAL,OAAYD,EAAEwH,UAAYvH,EAAEuH,WACvCC,EAAU,IAAIC,MAAOJ,GAAYK,OAAOC,KAAK,WAElD,MAAO,CAEN5C,MAAO,EACP1B,OAAQ,IAAIuE,aAAc,GAC1BC,iBAAkB,IAAID,aAAc,GACpCE,gBAAiB,IAAIF,aAAc,GACnCL,UAAW,MAKPQ,EAAa,IAAIH,aAAc,GAErC,SAASI,EAAiBC,EAAkBC,EAAsB9D,EAAgBU,EAAQC,EAAOoD,GAEhG,IAAIlB,GAAS,EACTF,EAAM,EAGV,GHhRqB,IGgRhBoB,GAGY,KADhBlB,EAAO7D,EAAqB8E,MAG3BnB,GAAQmB,EAAsBjB,GAASiB,EAAsBjB,EAAO,IAAQ,QAIvE,GHxRe,IGwRVkB,GAGK,KADhBlB,EAAO7D,EAAqB6E,MAG3BlB,EA+PH,SAAqB3C,EAAgBU,EAAQC,EAAOkC,GAGnD,IADA,IAAImB,EAAM,EACA3E,EAAIqB,EAAQgB,EAAMhB,EAASC,EAAOtB,EAAIqC,EAAKrC,IAEpD2E,GAAOhE,EAAoB,EAAJX,EAAe,EAAPwD,GAIhC,OAAOmB,EAAMrD,EAxQLsD,CAAYjE,EAAgBU,EAAQC,EAAOkC,SAI5C,GHhSW,IGgSNkB,EAQX,IANA,IAAMG,EAAkB7D,EAAoBwD,GACxCM,EAAWhG,EAA0BwC,EAGnCyD,EAAkB,EAAT1D,EACT2D,EAA4B,GAAnB3D,EAASC,GACdhF,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAM2I,EAAWR,EAAsBnI,GAGjC4I,GAFYT,EAAsBnI,EAAI,GACb2I,GACDrB,EAI9B,GAAKtC,EAAQsC,EAAgB,CAG5B,IAAMuB,GAAgB,OAAKpB,GAC3BoB,EAAcC,OAAS9D,EAIvB,IADA,IAAI/E,EAAI,EACEC,EAAIuI,EAAQvI,EAAIwI,EAAMxI,GAAK,EAAGD,IAAO,CAE9C,IAAM8I,EAAMF,EAAe5I,GAC3B8I,EAAIvB,UAAYnD,EAAgBnE,EAAI,EAAIF,GACxC+I,EAAI/D,MAAQ,EAOZ,IALA,IACC1B,EAGGyF,EAHHzF,OACAyE,EAEGgB,EAFHhB,gBACAD,EACGiB,EADHjB,iBAES7D,EAAI,EAAGA,EAAI,EAAGA,IAEvB6D,EAAkB7D,GAAMR,IACxBqE,EAAkB7D,EAAI,IAAQR,IAE9BsE,EAAiB9D,GAAMR,IACvBsE,EAAiB9D,EAAI,IAAQR,IAE7BH,EAAQW,GAAMR,IACdH,EAAQW,EAAI,IAAQR,IAIrBU,EAAwBjE,EAAGmE,EAAgBf,GAI5CuF,EAAcG,KAAMzB,GAIpB,IADA,IAAI0B,EAAajE,EACPkE,EAAK,EAAGA,EAAKD,EAAYC,IAGlC,IADA,IAAMH,EAAMF,EAAeK,GACnBA,EAAK,EAAID,GAAcJ,EAAeK,EAAK,GAAI1B,YAAcuB,EAAIvB,WAExEqB,EAAcM,OAAQD,EAAK,EAAG,GAC9BD,IAOF,IAAM,IAAI/I,EAAIuI,EAAQvI,EAAIwI,EAAMxI,GAAK,EAGpC,IADA,IAAMkJ,EAAS/E,EAAgBnE,EAAI,EAAIF,GAC7BkJ,EAAK,EAAGA,EAAKD,EAAYC,IAAQ,CAE1C,IAAMH,EAAMF,EAAeK,GACtBE,GAAUL,EAAIvB,UAElBrD,EAAwBjE,EAAGmE,EAAgB0E,EAAIjB,mBAI/C3D,EAAwBjE,EAAGmE,EAAgB0E,EAAIhB,iBAC/CgB,EAAI/D,SASP,IAAM,IAAIkE,EAAK,EAAGA,EAAKD,EAAYC,IAAQ,CAE1C,IAAMH,EAAMF,EAAeK,GACrBG,EAAYN,EAAI/D,MAChBsE,EAAatE,EAAQ+D,EAAI/D,MAGzBgD,EAAae,EAAIhB,gBACjBwB,EAAcR,EAAIjB,iBAEpB0B,EAAW,EACI,IAAdH,IAEJG,EAAW9E,EAAoBsD,GAAeO,GAI/C,IAAIkB,EAAY,EACI,IAAfH,IAEJG,EAAY/E,EAAoB6E,GAAgBhB,GAIjD,IAAMmB,EHxYmB,EGwYKlH,GAC7BgH,EAAWH,EAAYI,EAAYH,GAG/BI,EAAOlB,IAEXtB,EAAOlH,EACPwI,EAAWkB,EACX1C,EAAM+B,EAAIvB,gBAMN,CAGN,IAAM,IAAI9D,EAAI,EAAGA,EAAI4D,EAAW5D,IAAO,CAEtC,IAAMqF,EAAMtB,EAAS/D,GACrBqF,EAAI/D,MAAQ,EACZ+D,EAAIvB,UAAYmB,EAAWC,EAAWlF,EAAIkF,EAG1C,IADA,IAAMtF,EAASyF,EAAIzF,OACTW,EAAI,EAAGA,EAAI,EAAGA,IAEvBX,EAAQW,GAAMR,IACdH,EAAQW,EAAI,IAAQR,IAOtB,IAAM,IAAIvD,GAAIuI,EAAQvI,GAAIwI,EAAMxI,IAAK,EAAI,CAExC,IAKIyJ,OALctF,EAAgBnE,GAAI,EAAIF,GACP2I,GAIGC,GACjCe,IAAYrC,IAAYqC,GAAWrC,IAExC,IAAMyB,GAAMtB,EAASkC,IACrBZ,GAAI/D,QAEJb,EAAwBjE,GAAGmE,EAAgB0E,GAAIzF,QAKhD,IAAMsG,GAAUnC,EAASH,IACzB1D,EAAYgG,GAAQtG,OAAQsG,GAAQ9B,kBACpC,IAAM,IAAIpE,GAAI4D,GAAe5D,IAAK,EAAGA,KAAO,CAE3C,IAAMqF,GAAMtB,EAAS/D,IACfmG,GAAUpC,EAAS/D,GAAI,GAC7BI,EAAaiF,GAAIzF,OAAQuG,GAAQ/B,iBAAkBiB,GAAIjB,kBAKxD,IADA,IAAIuB,GAAY,EACN3F,GAAI,EAAGA,GAAI4D,GAAe5D,KAAO,CAE1C,IAAMqF,GAAMtB,EAAS/D,IACfoG,GAAWf,GAAI/D,MACf1B,GAASyF,GAAIzF,OAGbiG,GADU9B,EAAS/D,GAAI,GACDoE,iBAGV,IAAbgC,KAEe,IAAdT,GAEJzF,EAAYN,GAAQ0E,GAIpBlE,EAAaR,GAAQ0E,EAAYA,IASnC,IAAIwB,GAAW,EACXC,GAAY,EAEG,KANnBJ,IAAaS,MAQZN,GAAW9E,EAAoBsD,GAAeO,GAI/C,IAAMe,GAAatE,EAAQqE,GACP,IAAfC,KAEJG,GAAY/E,EAAoB6E,IAAgBhB,GAIjD,IAAMmB,GHlfmB,EGkfKlH,GAC7BgH,GAAWH,GAAYI,GAAYH,IAG/BI,GAAOlB,IAEXtB,EAAOlH,EACPwI,EAAWkB,GACX1C,EAAM+B,GAAIvB,kBAYduC,QAAQC,KAAR,gDAAwD5B,EAAxD,WAID,MAAO,CAAElB,KAAAA,EAAMF,IAAAA,GAgFT,SAASiD,EAAWzI,EAAK0I,GAE/B,SAASC,EAAiBC,GAEpBC,GAEJA,EAAYD,EAAqBE,GAQnC,SAASC,EAAWC,EAAMzF,EAAQC,GAAgD,IAAzCmD,EAAyC,uDAAlB,KAAMsC,EAAY,uDAAJ,EAe7E,IAbOC,GAAmBD,GAASE,IAElCD,GAAkB,EACbE,IAEJb,QAAQC,KAAR,gCAAwCW,EAAxC,gEACAZ,QAAQC,KAAMxI,KAOXwD,GAAS6F,GAAeJ,GAASE,EAKrC,OAHAR,EAAiBpF,EAASC,GAC1BwF,EAAKzF,OAASA,EACdyF,EAAKxF,MAAQA,EACNwF,EAKR,IAAM3D,EAAQoB,EAAiBuC,EAAKM,aAAc3C,EAAsB9D,EAAgBU,EAAQC,EAAOoD,GACvG,IAAsB,IAAjBvB,EAAMK,KAKV,OAHAiD,EAAiBpF,EAASC,GAC1BwF,EAAKzF,OAASA,EACdyF,EAAKxF,MAAQA,EACNwF,EAIR,IAAMO,EAAcnE,EAAWoE,EAAY3G,EAAgBU,EAAQC,EAAO6B,GAG1E,GAAKkE,IAAgBhG,GAAUgG,IAAgBhG,EAASC,EAEvDmF,EAAiBpF,EAASC,GAC1BwF,EAAKzF,OAASA,EACdyF,EAAKxF,MAAQA,MAEP,CAENwF,EAAKS,UAAYpE,EAAMK,KAGvB,IAAMJ,EAAO,IAAIhE,EACXoI,EAASnG,EACToG,EAASJ,EAAchG,EAC7ByF,EAAK1D,KAAOA,EACZA,EAAKgE,aAAe,IAAIjD,aAAc,GAEtC/C,EAAWT,EAAgB6G,EAAQC,EAAQrE,EAAKgE,aAAcM,GAC9Db,EAAWzD,EAAMoE,EAAQC,EAAQC,EAA2BX,EAAQ,GAGpE,IAAM1D,EAAQ,IAAIjE,EACZuI,EAASN,EACTO,EAAStG,EAAQmG,EACvBX,EAAKzD,MAAQA,EACbA,EAAM+D,aAAe,IAAIjD,aAAc,GAEvC/C,EAAWT,EAAgBgH,EAAQC,EAAQvE,EAAM+D,aAAcM,GAC/Db,EAAWxD,EAAOsE,EAAQC,EAAQF,EAA2BX,EAAQ,GAItE,OAAOD,GArrBT,SAAsBhJ,EAAK0I,GAE1B,IAAO1I,EAAII,MAAQ,CAElB,IAEIA,EAFE2J,EAAc/J,EAAIM,WAAWhD,SAASkG,MACtCwG,EAAoBtB,EAAQuB,qBAAuBC,kBAAoBC,YAI5E/J,EAFI2J,EAAc,MAEV,IAAIK,YAAa,IAAIJ,EAAmB,EAAID,IAI5C,IAAIM,YAAa,IAAIL,EAAmB,EAAID,IAIrD/J,EAAIsK,SAAU,IAAIC,EAAAA,gBAAiBnK,EAAO,IAE1C,IAAM,IAAI8B,EAAI,EAAGA,EAAI6H,EAAa7H,IAEjC9B,EAAO8B,GAAMA,GAoqBfsI,CAAaxK,EAAK0I,GAKlB,IAAM+B,EAAa,IAAIpE,aAAc,GAC/BuD,EAA4B,IAAIvD,aAAc,GAC9CxD,EAzJP,SAAgC7C,EAAKyK,GAEpC,IAAMC,EAAU1K,EAAIM,WAAWhD,SACzBqN,EAASD,EAAQjJ,MACjBrB,EAAQJ,EAAII,MAAMqB,MAClBmJ,EAAWxK,EAAMkH,OAAS,EAC1BzE,EAAiB,IAAIwD,aAAyB,EAAXuE,GAGnCC,EAAeH,EAAQnH,QAAU,EACnCuH,EAAS,EACRJ,EAAQK,+BAEZD,EAASJ,EAAQM,KAAKF,QAIvB,IAAM,IAAI7K,EAAM,EAAGA,EAAM2K,EAAU3K,IAQlC,IANA,IAAMgL,EAAa,EAANhL,EACPiL,EAAa,EAANjL,EACPkL,EAAK/K,EAAO6K,EAAO,GAAMH,EAASD,EAClCnD,EAAKtH,EAAO6K,EAAO,GAAMH,EAASD,EAClCO,EAAKhL,EAAO6K,EAAO,GAAMH,EAASD,EAE9BQ,EAAK,EAAGA,EAAK,EAAGA,IAAQ,CAEjC,IAAM7M,EAAImM,EAAQQ,EAAKE,GACjB5M,EAAIkM,EAAQjD,EAAK2D,GACjB3M,EAAIiM,EAAQS,EAAKC,GAEnB1J,EAAMnD,EACLC,EAAIkD,IAAMA,EAAMlD,GAChBC,EAAIiD,IAAMA,EAAMjD,GAErB,IAAIkD,EAAMpD,EACLC,EAAImD,IAAMA,EAAMnD,GAChBC,EAAIkD,IAAMA,EAAMlD,GAKrB,IAAM4M,GAAgB1J,EAAMD,GAAQ,EAC9B4J,EAAW,EAALF,EACZxI,EAAgBqI,EAAOK,EAAM,GAAM5J,EAAM2J,EACzCzI,EAAgBqI,EAAOK,EAAM,GAAMD,GAAgBlK,KAAKoK,IAAK7J,GAAQ2J,GAAgBnK,EAEhFQ,EAAM8I,EAAYY,KAAOZ,EAAYY,GAAO1J,GAC5CC,EAAM6I,EAAYY,EAAK,KAAMZ,EAAYY,EAAK,GAAMzJ,GAM3D,OAAOiB,EAmGgB4I,CAAuBzL,EAAKyK,GAC7CjB,EAAaxJ,EAAII,MAAMqB,MACvB0H,EAAWT,EAAQS,SACnBC,EAAUV,EAAQU,QAClBC,EAAcX,EAAQW,YACtBzC,EAAW8B,EAAQ9B,SACnBiC,EAAaH,EAAQG,WACrBC,EAAiB9I,EAAII,MAAMoD,MAAQ,EACrC0F,GAAkB,EAEhBwC,EAAQ,GACRC,EAnqBP,SAA6B3L,GAE5B,IAAOA,EAAI4L,SAAY5L,EAAI4L,OAAOtE,OAEjC,MAAO,CAAE,CAAE/D,OAAQ,EAAGC,MAAOxD,EAAII,MAAMoD,MAAQ,IAIhD,IARkC,EAQ5BmI,EAAS,GACTE,EAAkB,IAAIC,IATM,UAUb9L,EAAI4L,QAVS,IAUlC,IAAK,EAAL,qBAAkC,KAAtBG,EAAsB,QAEjCF,EAAgB3O,IAAK6O,EAAMC,OAC3BH,EAAgB3O,IAAK6O,EAAMC,MAAQD,EAAMvI,QAbR,8BAmBlC,IADA,IAAMyI,EAAmB/F,MAAMgG,KAAML,EAAgBM,UAAW3E,MAAM,SAAEhJ,EAAGC,GAAL,OAAYD,EAAIC,KAC5EyD,EAAI,EAAGA,EAAI+J,EAAiB3E,OAAS,EAAGpF,IAAO,CAExD,IAAM8J,EAAQC,EAAkB/J,GAAKqC,EAAM0H,EAAkB/J,EAAI,GACjEyJ,EAAOpL,KAAM,CAAEgD,OAAUyI,EAAQ,EAAKxI,OAASe,EAAMyH,GAAU,IAIhE,OAAOL,EAyoBQS,CAAoBpM,GAEnC,GAAuB,IAAlB2L,EAAOrE,OAAe,CAE1B,IAAM+E,EAAQV,EAAQ,GAChBW,EAAO,IAAIhL,EACjBgL,EAAKhD,aAAemB,EAjkBtB,SAA4B5H,EAAgBU,EAAQC,EAAOC,GAS1D,IAPA,IAAIO,EAAQ/B,IACRgC,EAAQhC,IACRiC,EAAQjC,IACRkC,GAAQ,IACRC,GAAQ,IACRC,GAAQ,IAEFnC,EAAa,EAATqB,EAAYgB,EAA2B,GAAnBhB,EAASC,GAAatB,EAAIqC,EAAKrC,GAAK,EAAI,CAEzE,IAAMsC,EAAK3B,EAAgBX,EAAI,GAC1BsC,EAAKR,IAAQA,EAAQQ,GACrBA,EAAKL,IAAQA,EAAQK,GAE1B,IAAMI,EAAK/B,EAAgBX,EAAI,GAC1B0C,EAAKX,IAAQA,EAAQW,GACrBA,EAAKR,IAAQA,EAAQQ,GAE1B,IAAMI,EAAKnC,EAAgBX,EAAI,GAC1B8C,EAAKd,IAAQA,EAAQc,GACrBA,EAAKX,IAAQA,EAAQW,GAI3BvB,EAAgB,GAAMO,EACtBP,EAAgB,GAAMQ,EACtBR,EAAgB,GAAMS,EAEtBT,EAAgB,GAAMU,EACtBV,EAAgB,GAAMW,EACtBX,EAAgB,GAAMY,EAmiBrBkI,CAAmB1J,EAAgBwJ,EAAM9I,OAAQ8I,EAAM7I,MAAOoG,GAE9Db,EAAWuD,EAAMD,EAAM9I,OAAQ8I,EAAM7I,MAAOoG,GAC5C8B,EAAMnL,KAAM+L,OAEN,iBAEaX,GAFb,IAEN,IAAK,EAAL,qBAA4B,KAAlBU,EAAkB,QAErBC,EAAO,IAAIhL,EACjBgL,EAAKhD,aAAe,IAAIjD,aAAc,GACtC/C,EAAWT,EAAgBwJ,EAAM9I,OAAQ8I,EAAM7I,MAAO8I,EAAKhD,aAAcM,GAEzEb,EAAWuD,EAAMD,EAAM9I,OAAQ8I,EAAM7I,MAAOoG,GAC5C8B,EAAMnL,KAAM+L,IATP,+BAeP,OAAOZ,EAID,SAASc,EAAiBxM,EAAK0I,GAYrC,IAPA,IAEI+D,EACAC,EACAC,EAJEjB,EAAQjD,EAAWzI,EAAK0I,GAKxBkE,EAAc,GACd5C,EAAoBtB,EAAQuB,qBAAuBC,kBAAoBC,YACnEjI,EAAI,EAAGA,EAAIwJ,EAAMpE,OAAQpF,IAAO,CAEzC,IAAMoK,EAAOZ,EAAOxJ,GAChB2K,EAAYC,EAAYR,GAEtBS,EAAS,IAAI/C,EAAmB/I,EAAiB4L,GACvDJ,EAAe,IAAIpG,aAAc0G,GACjCL,EAAc,IAAItC,YAAa2C,GAC/BJ,EAAc,IAAItC,YAAa0C,GAC/BC,EAAgB,EAAGV,GACnBM,EAAYrM,KAAMwM,GAInB,OAAOH,EAEP,SAASE,EAAY9D,GAEpB,OAAKA,EAAKxF,MAEF,EAIA,EAAIsJ,EAAY9D,EAAK1D,MAASwH,EAAY9D,EAAKzD,OAMxD,SAASyH,EAAgBC,EAAYjE,GAMpC,IAJA,IAAMkE,EAAgBD,EAAa,EAC7BE,EAAgBF,EAAa,EAC7BG,IAAapE,EAAKxF,MAClB8F,EAAeN,EAAKM,aAChBpH,EAAI,EAAGA,EAAI,EAAGA,IAEvBuK,EAAcS,EAAgBhL,GAAMoH,EAAcpH,GAInD,GAAKkL,EAAS,CAEb,IAAM7J,EAASyF,EAAKzF,OACdC,EAAQwF,EAAKxF,MAInB,OAHAkJ,EAAaQ,EAAgB,GAAM3J,EACnCoJ,EAAaQ,EAAgB,IAAO3J,EACpCmJ,EAAaQ,EAAgB,IAAOjM,EAC7B+L,EAAahM,EAIpB,IAIIoM,EAJE/H,EAAO0D,EAAK1D,KACZC,EAAQyD,EAAKzD,MACbkE,EAAYT,EAAKS,UAKvB,IAFA4D,EAAoBL,EAAgBC,EAAahM,EAAgBqE,IAEtC,EAAMlE,KAAKC,IAAK,EAAG,IAE7C,MAAM,IAAIiM,MAAO,6DAQlB,OAJAZ,EAAaQ,EAAgB,GAAMG,EAAoB,EACvDA,EAAoBL,EAAgBK,EAAmB9H,GAEvDmH,EAAaQ,EAAgB,GAAMzD,EAC5B4D,G,2CCl0BGE,EAAb,WAEC,cAAc,eAEbC,KAAK7L,IAAMM,IACXuL,KAAK5L,KAAQK,IALf,iDASC,SAAoBwL,EAAQC,GAI3B,IAFA,IAAI/L,EAAMM,IACNL,GAAQK,IACFC,EAAI,EAAGyL,EAAIF,EAAOnG,OAAQpF,EAAIyL,EAAGzL,IAAO,CAEjD,IACM0L,EADIH,EAAQvL,GACHwL,GACf/L,EAAMiM,EAAMjM,EAAMiM,EAAMjM,EACxBC,EAAMgM,EAAMhM,EAAMgM,EAAMhM,EAIzB4L,KAAK7L,IAAMA,EACX6L,KAAK5L,IAAMA,IAvBb,2BA2BC,SAAe8D,EAAM+H,GAIpB,IAFA,IAAI9L,EAAMM,IACNL,GAAQK,IACFC,EAAI,EAAGyL,EAAIF,EAAOnG,OAAQpF,EAAIyL,EAAGzL,IAAO,CAEjD,IAAM2L,EAAIJ,EAAQvL,GACZ0L,EAAMlI,EAAKoI,IAAKD,GACtBlM,EAAMiM,EAAMjM,EAAMiM,EAAMjM,EACxBC,EAAMgM,EAAMhM,EAAMgM,EAAMhM,EAIzB4L,KAAK7L,IAAMA,EACX6L,KAAK5L,IAAMA,IAzCb,yBA6CC,SAAamM,GAEZ,OAAOP,KAAK7L,IAAMoM,EAAMnM,KAAOmM,EAAMpM,IAAM6L,KAAK5L,QA/ClD,KAqDA2L,EAAqBS,UAAUC,WAAe,WAE7C,IAAMJ,EAAI,IAAIhQ,EAAAA,QACd,OAAO,SAAqB6H,EAAMwI,GAMjC,IAJA,IAAMC,EAASD,EAAIvM,IACbyM,EAASF,EAAItM,IACfD,EAAMM,IACNL,GAAQK,IACFzE,EAAI,EAAGA,GAAK,EAAGA,IAExB,IAAM,IAAIC,EAAI,EAAGA,GAAK,EAAGA,IAExB,IAAM,IAAIC,EAAI,EAAGA,GAAK,EAAGA,IAAO,CAE/BmQ,EAAErQ,EAAI2Q,EAAO3Q,EAAIA,EAAI4Q,EAAO5Q,GAAM,EAAIA,GACtCqQ,EAAEpQ,EAAI0Q,EAAO1Q,EAAIA,EAAI2Q,EAAO3Q,GAAM,EAAIA,GACtCoQ,EAAEnQ,EAAIyQ,EAAOzQ,EAAIA,EAAI0Q,EAAO1Q,GAAM,EAAIA,GAEtC,IAAMkQ,EAAMlI,EAAKoI,IAAKD,GACtBlM,EAAMP,KAAKO,IAAKiM,EAAKjM,GACrBC,EAAMR,KAAKQ,IAAKgM,EAAKhM,GAQxB4L,KAAK7L,IAAMA,EACX6L,KAAK5L,IAAMA,GA9BiC,IAoCb,WAEhC,IAAMyM,EAAiB,IAAId,EAFK,GAA1B,ICzFMe,EAA2B,WAGvC,IAAMC,EAAO,IAAI1Q,EAAAA,QACX2Q,EAAO,IAAI3Q,EAAAA,QACX4Q,EAAM,IAAI5Q,EAAAA,QAChB,OAAO,SAAiC6Q,EAAIC,EAAIC,GAE/C,IAAMC,EAAKH,EAAG1C,MACR8C,EAAMP,EACNQ,EAAKJ,EAAG3C,MACRgD,EAAMR,EAEZC,EAAIQ,WAAYJ,EAAIE,GACpBR,EAAKU,WAAYP,EAAGnK,IAAKoK,EAAG3C,OAC5BwC,EAAKS,WAAYN,EAAGpK,IAAKoK,EAAG3C,OAG5B,IAiBIvJ,EAAGY,EAjBD6L,EAAQT,EAAIX,IAAKkB,GAGjBG,EAAQH,EAAIlB,IAAKgB,GAGjBM,EAAQJ,EAAIlB,IAAKkB,GAGjBK,EAAQZ,EAAIX,IAAKgB,GAMjBQ,EAHQR,EAAIhB,IAAKgB,GAGDM,EAAQD,EAAQA,EAatC9L,GAAO6L,GARNzM,EAFc,IAAV6M,GAEEJ,EAAQC,EAAQE,EAAQD,GAAUE,EAIpC,GAIcH,GAAUC,EAE7BR,EAAOpR,EAAIiF,EACXmM,EAAOnR,EAAI4F,GAjD2B,GAuD3BkM,EAAkC,WAG9C,IAAMC,EAAc,IAAIvR,EAAAA,QAClBwR,EAAQ,IAAI5R,EAAAA,QACZ6R,EAAQ,IAAI7R,EAAAA,QAClB,OAAO,SAAwC6Q,EAAIC,EAAIgB,EAASC,GAE/DtB,EAAwBI,EAAIC,EAAIa,GAEhC,IA4CK3B,EAWAgC,EAvDDpN,EAAI+M,EAAYhS,EAChB6F,EAAKmM,EAAY/R,EACrB,GAAKgF,GAAK,GAAKA,GAAK,GAAKY,GAAM,GAAKA,GAAM,EAKzC,OAHAqL,EAAGoB,GAAIrN,EAAGkN,QACVhB,EAAGmB,GAAIzM,EAAIuM,GAIL,GAAKnN,GAAK,GAAKA,GAAK,EAc1B,OAXKY,EAAK,EAETsL,EAAGmB,GAAI,EAAGF,GAIVjB,EAAGmB,GAAI,EAAGF,QAIXlB,EAAGqB,oBAAqBH,GAAS,EAAMD,GAGjC,GAAKtM,GAAM,GAAKA,GAAM,EAc5B,OAXKZ,EAAI,EAERiM,EAAGoB,GAAI,EAAGH,GAIVjB,EAAGoB,GAAI,EAAGH,QAIXhB,EAAGoB,oBAAqBJ,GAAS,EAAMC,GAStC/B,EAFIpL,EAAI,EAEJiM,EAAG1C,MAIH0C,EAAGnK,IAOPsL,EAFIxM,EAAK,EAEJsL,EAAG3C,MAIH2C,EAAGpK,IAIT,IAAMyL,EAAeP,EACfQ,EAAgBP,EAItB,OAHAhB,EAAGqB,oBAAqBF,GAAI,EAAMJ,GAClCd,EAAGoB,oBAAqBlC,GAAG,EAAM6B,GAE5BM,EAAaE,kBAAmBL,IAAQI,EAAcC,kBAAmBrC,IAE7E8B,EAAQQ,KAAMH,QACdJ,EAAQO,KAAMN,KAKdF,EAAQQ,KAAMtC,QACd+B,EAAQO,KAAMF,KA1F6B,GAsGlCG,EAA4B,WAGxC,IAAMC,EAAmB,IAAIxS,EAAAA,QACvByS,EAAqB,IAAIzS,EAAAA,QACzB0S,EAAY,IAAIC,EAAAA,MAChBC,EAAW,IAAIC,EAAAA,MACrB,OAAO,SAAkCC,EAAQC,GAEhD,IAAQC,EAAmBF,EAAnBE,OAAQjJ,EAAW+I,EAAX/I,OACRpJ,EAAYoS,EAAZpS,EAAGC,EAASmS,EAATnS,EAAGC,EAAMkS,EAANlS,EAMd,GAHA+R,EAASzE,MAAQxN,EACjBiS,EAASlM,IAAM9F,EACOgS,EAASV,oBAAqBnI,GAAQ,EAAMyI,GAC/C9Q,WAAYqI,IAAYiJ,EAAS,OAAO,EAK3D,GAHAJ,EAASzE,MAAQxN,EACjBiS,EAASlM,IAAM7F,EACO+R,EAASV,oBAAqBnI,GAAQ,EAAMyI,GAC/C9Q,WAAYqI,IAAYiJ,EAAS,OAAO,EAK3D,GAHAJ,EAASzE,MAAQvN,EACjBgS,EAASlM,IAAM7F,EACO+R,EAASV,oBAAqBnI,GAAQ,EAAMyI,GAC/C9Q,WAAYqI,IAAYiJ,EAAS,OAAO,EAG3D,IAAMC,EAAQF,EAASG,SAAUR,GAEjC,GADWnP,KAAKoK,IAAKsF,EAAME,gBAAiBpJ,KACjCiJ,EAAS,CAEnB,IAAMI,EAAKH,EAAMI,aAActJ,EAAQ0I,GAEvC,GADWM,EAASO,cAAeF,GACzB,OAAO,EAIlB,OAAO,GAvCgC,GC1JzC,SAASG,EAAYC,GAEpB,OAAOjQ,KAAKoK,IAAK6F,GAHG,MAOd,IAAMC,EAAb,0CAEC,aAAuB,iDAAPC,EAAO,yBAAPA,EAAO,uBAEtB,+BAAUA,KAELC,oBAAqB,EAC1B,EAAKC,QAAU,IAAIvL,MAAO,GAAIC,OAAOC,KAAK,kBAAM,IAAIvI,EAAAA,WACpD,EAAK6T,UAAY,IAAIxL,MAAO,GAAIC,OAAOC,KAAK,kBAAM,IAAImH,KACtD,EAAKE,OAAS,CAAE,EAAKjP,EAAG,EAAKC,EAAG,EAAKC,GACrC,EAAKiS,OAAS,IAAIgB,EAAAA,OAClB,EAAKb,MAAQ,IAAIN,EAAAA,MACjB,EAAKoB,aAAc,EAVG,EAFxB,+CAgBC,SAAkBjB,GAEjB,OAAOP,EAAyBO,EAAQnD,QAlB1C,oBAsBC,WAEC,IAAMhP,EAAIgP,KAAKhP,EACTC,EAAI+O,KAAK/O,EACTC,EAAI8O,KAAK9O,EACT+O,EAASD,KAAKC,OAEdgE,EAAUjE,KAAKiE,QACfC,EAAYlE,KAAKkE,UAEjBG,EAAQJ,EAAS,GACjBK,EAAOJ,EAAW,GACxBlE,KAAKuE,UAAWF,GAChBC,EAAKE,cAAeH,EAAOpE,GAE3B,IAAMwE,EAAQR,EAAS,GACjBS,EAAOR,EAAW,GACxBO,EAAMhD,WAAYzQ,EAAGC,GACrByT,EAAKF,cAAeC,EAAOxE,GAE3B,IAAM0E,EAAQV,EAAS,GACjBW,EAAOV,EAAW,GACxBS,EAAMlD,WAAYxQ,EAAGC,GACrB0T,EAAKJ,cAAeG,EAAO1E,GAE3B,IAAM4E,EAAQZ,EAAS,GACjBa,EAAOZ,EAAW,GACxBW,EAAMpD,WAAYvQ,EAAGF,GACrB8T,EAAKN,cAAeK,EAAO5E,GAE3BD,KAAKmD,OAAOqB,cAAexE,KAAKC,QAChCD,KAAKsD,MAAMyB,8BAA+BV,EAAOrT,GACjDgP,KAAKoE,aAAc,MAtDrB,GAAsClS,EAAAA,UA4DtC4R,EAAiBtD,UAAUwE,sBAA0B,WAEpD,IAAMC,EAAS,IAAI5U,EAAAA,QACb6U,EAAS,IAAI7U,EAAAA,QACb8U,EAAO,IAAIjC,EAAAA,MAEjB,OAAO,SAA4BkC,GAQlC,IAR4E,IAIxEC,EAJuClD,EAAiC,uDAAvB,KAAMC,EAAiB,uDAAP,KAE7D5D,EAAe4G,EAAf5G,MAAOzH,EAAQqO,EAARrO,IACTkJ,EAASD,KAAKC,OAEhBqF,EAAoB7Q,IAGdC,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAM6Q,GAAU7Q,EAAI,GAAM,EAC1ByQ,EAAK3G,MAAMmE,KAAM1C,EAAQvL,IACzByQ,EAAKpO,IAAI4L,KAAM1C,EAAQsF,IAEvBxD,EAA+BoD,EAAMC,EAASH,EAAQC,IAEtDG,EAASJ,EAAOvC,kBAAmBwC,IACrBI,IAEbA,EAAoBD,EACflD,GAAUA,EAAQQ,KAAMsC,GACxB7C,GAAUA,EAAQO,KAAMuC,IA2B/B,OApBAlF,KAAKuC,oBAAqB/D,EAAOyG,IACjCI,EAAS7G,EAAMkE,kBAAmBuC,IACpBK,IAEbA,EAAoBD,EACflD,GAAUA,EAAQQ,KAAMsC,GACxB7C,GAAUA,EAAQO,KAAMnE,IAI9BwB,KAAKuC,oBAAqBxL,EAAKkO,IAC/BI,EAAStO,EAAI2L,kBAAmBuC,IAClBK,IAEbA,EAAoBD,EACflD,GAAUA,EAAQQ,KAAMsC,GACxB7C,GAAUA,EAAQO,KAAM5L,IAIvBnD,KAAK4R,KAAMF,IAtDiC,GA4DrDxB,EAAiBtD,UAAUiF,mBAAuB,WAEjD,IAAMC,EAAS,IAAI5B,EACb6B,EAAO,IAAIjN,MAAO,GAClBkN,EAAO,IAAIlN,MAAO,GAClBmN,EAAkB,IAAI9F,EACtB+F,EAAmB,IAAI/F,EACvBgG,EAAa,IAAI1V,EAAAA,QACjB0Q,EAAO,IAAI1Q,EAAAA,QACX2Q,EAAO,IAAI3Q,EAAAA,QACX2V,EAAU,IAAI3V,EAAAA,QACd8U,EAAO,IAAIjC,EAAAA,MACX+C,EAAQ,IAAI/C,EAAAA,MACZgD,EAAQ,IAAIhD,EAAAA,MAIlB,OAAO,SAA6B3C,GAAuB,IAAhBrM,EAAgB,uDAAP,KAE9C8L,KAAKoE,aAETpE,KAAKmG,SAIC5F,EAAMyD,mBAMDzD,EAAM6D,aAEjB7D,EAAM4F,UANNT,EAAO/C,KAAMpC,GACbmF,EAAOS,SACP5F,EAAQmF,GAQT,IAAMU,EAASpG,KAAKsD,MACd+C,EAAS9F,EAAM+C,MAErB,GAAK1P,KAAKoK,IAAKoI,EAAOhU,OAAOkO,IAAK+F,EAAOjU,SAAa,EAAM,MAAQ,CAGnE,IAAMkU,EAAatG,KAAKkE,UAClBqC,EAAWvG,KAAKiE,QACtB2B,EAAM,GAAMrF,EAAMvP,EAClB4U,EAAM,GAAMrF,EAAMtP,EAClB2U,EAAM,GAAMrF,EAAMrP,EAClB,IAAM,IAAIwD,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAM8R,EAAKF,EAAY5R,GACjB+R,EAAKF,EAAU7R,GAErB,GADAmR,EAAgBrB,cAAeiC,EAAIb,GAC9BY,EAAGE,YAAab,GAAoB,OAAO,EAIjD,IAAMc,EAAapG,EAAM2D,UACnB0C,EAAWrG,EAAM0D,QACvB0B,EAAM,GAAM3F,KAAKhP,EACjB2U,EAAM,GAAM3F,KAAK/O,EACjB0U,EAAM,GAAM3F,KAAK9O,EACjB,IAAM,IAAIwD,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAM8R,EAAKG,EAAYjS,GACjB+R,EAAKG,EAAUlS,GAErB,GADAmR,EAAgBrB,cAAeiC,EAAId,GAC9Ba,EAAGE,YAAab,GAAoB,OAAO,EAKjD,IAAM,IAAInR,EAAI,EAAGA,EAAI,EAAGA,IAGvB,IADA,IAAMmS,EAAMN,EAAU7R,GACZoS,EAAK,EAAGA,EAAK,EAAGA,IAAQ,CAEjC,IAAMC,EAAMH,EAAUE,GAItB,GAHAf,EAAWiB,aAAcH,EAAKE,GAC9BlB,EAAgBrB,cAAeuB,EAAYJ,GAC3CG,EAAiBtB,cAAeuB,EAAYH,GACvCC,EAAgBa,YAAaZ,GAAqB,OAAO,EAgBhE,OAVK5R,IAGJ6G,QAAQC,KAAM,+HAEd9G,EAAOsK,MAAMzO,IAAK,EAAG,EAAG,GACxBmE,EAAO6C,IAAIhH,IAAK,EAAG,EAAG,KAIhB,EAQP,IAHA,IAAMkX,EAAUjH,KAAKC,OACjBiH,GAAS,EACTC,EAAS,EACHzS,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAM2L,EAAI4G,EAASvS,GACb0S,EAAQH,GAAWvS,EAAI,GAAM,GAEnCyQ,EAAK3G,MAAMmE,KAAMtC,GACjB8E,EAAKpO,IAAI4L,KAAMyE,GACfjC,EAAKkC,MAAOtG,GAEZ,IAAMuG,EAAcJ,EAASjB,EAAMzH,MAAQyH,EAAMlP,IAC3CwQ,EAAkB3D,EAAYyC,EAAO7C,gBAAiBnD,IAC5D,GAAKuD,EAAYyC,EAAOjU,OAAOkO,IAAKS,KAAYwG,EAAkB,CAGjEtB,EAAMtD,KAAMwC,GACZgC,EAAS,EACT,MAKD,IAAMK,EAAgBnB,EAAOoB,cAAetC,EAAMmC,IAAiBC,EACnE,GAAKC,IAAmB5D,EAAY0D,EAAYvV,WAAYqV,IAAY,CAGvE,GADAD,IACKD,EAEJ,MAIDA,GAAS,GAMX,GAAgB,IAAXC,GAAgBnH,KAAK2D,cAAesC,EAAMzH,OAS9C,OAPKtK,IAEJA,EAAOsK,MAAMmE,KAAMsD,EAAMzH,OACzBtK,EAAO6C,IAAI4L,KAAMsD,EAAMzH,SAIjB,EAED,GAAgB,IAAX2I,EAEX,OAAO,EAQR,IAHA,IAAMO,EAAUnH,EAAMN,OAClB0H,GAAS,EACTC,EAAS,EACHlT,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAM2L,EAAIqH,EAAShT,GACb0S,EAAQM,GAAWhT,EAAI,GAAM,GAEnCyQ,EAAK3G,MAAMmE,KAAMtC,GACjB8E,EAAKpO,IAAI4L,KAAMyE,GACfjC,EAAKkC,MAAOrG,GAEZ,IAAMsG,EAAcK,EAASzB,EAAM1H,MAAQ0H,EAAMnP,IAC3CwQ,EAAkB3D,EAAYwC,EAAO5C,gBAAiBnD,IAC5D,GAAKuD,EAAYwC,EAAOhU,OAAOkO,IAAKU,KAAYuG,EAAkB,CAGjErB,EAAMvD,KAAMwC,GACZyC,EAAS,EACT,MAKD,IAAMJ,EAAgBpB,EAAOqB,cAAetC,EAAMmC,IAAiBC,EACnE,GAAKC,IAAmB5D,EAAY0D,EAAYvV,WAAYqV,IAAY,CAGvE,GADAQ,IACKD,EAEJ,MAIDA,GAAS,GAMX,GAAgB,IAAXC,GAAgB5H,KAAK2D,cAAeuC,EAAM1H,OAS9C,OAPKtK,IAEJA,EAAOsK,MAAMmE,KAAMuD,EAAM1H,OACzBtK,EAAO6C,IAAI4L,KAAMuD,EAAM1H,SAIjB,EAED,GAAgB,IAAXoJ,EAEX,OAAO,EAQR,GAHA3B,EAAMoB,MAAOtG,GACbmF,EAAMmB,MAAOrG,GAERD,EAAKT,IAAKU,GAAS,EAAI,CAE3B,IAAI6G,EAAM3B,EAAM1H,MAChB0H,EAAM1H,MAAQ0H,EAAMnP,IACpBmP,EAAMnP,IAAM8Q,EAKb,IAAMC,EAAK7B,EAAMzH,MAAM8B,IAAKS,GACtBgH,EAAK9B,EAAMlP,IAAIuJ,IAAKS,GACpBiH,EAAK9B,EAAM1H,MAAM8B,IAAKS,GACtBkH,EAAK/B,EAAMnP,IAAIuJ,IAAKS,GACpBmH,GAAaH,EAAKC,EAClBG,GAAaL,EAAKG,EAExB,OAAKH,IAAOG,GAAMD,IAAOD,GAAMG,KAAeC,MAOzCjU,IAEJ8R,EAAQvE,WAAYwE,EAAMzH,MAAO0H,EAAM1H,OAClCwH,EAAQ1F,IAAKS,GAAS,EAE1B7M,EAAOsK,MAAMmE,KAAMsD,EAAMzH,OAIzBtK,EAAOsK,MAAMmE,KAAMuD,EAAM1H,OAI1BwH,EAAQvE,WAAYwE,EAAMlP,IAAKmP,EAAMnP,KAChCiP,EAAQ1F,IAAKS,GAAS,EAE1B7M,EAAO6C,IAAI4L,KAAMsD,EAAMlP,KAIvB7C,EAAO6C,IAAI4L,KAAMuD,EAAMnP,OAMlB,IA9QwC,GAuRlD+M,EAAiBtD,UAAUgD,gBAAoB,WAE9C,IAAMtP,EAAS,IAAI7D,EAAAA,QACnB,OAAO,SAA0BoB,GAGhC,OADAuO,KAAKuC,oBAAqB9Q,EAAOyC,GAC1BzC,EAAMM,WAAYmC,IANoB,GAa/C4P,EAAiBtD,UAAU4H,mBAAuB,WAEjD,IAAM3W,EAAQ,IAAIpB,EAAAA,QACZ6U,EAAS,IAAI7U,EAAAA,QACbgY,EAAe,CAAE,IAAK,IAAK,KAC3BC,EAAQ,IAAIpF,EAAAA,MACZqF,EAAQ,IAAIrF,EAAAA,MAElB,OAAO,SAA6B3C,GAAwC,IAAjC4B,EAAiC,uDAAvB,KAAMC,EAAiB,uDAAP,KAE9DoG,EAAarG,GAAWC,EAAUkG,EAAQ,KAChD,GAAKtI,KAAKyF,mBAAoBlF,EAAOiI,GASpC,OAPKrG,GAAWC,KAEVD,GAAUqG,EAAWC,UAAWtG,GAChCC,GAAUoG,EAAWC,UAAWrG,IAI/B,EAOR,IAHA,IAAIkD,EAAoB7Q,IAGdC,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAIC,OAAI,EACFuL,EAAQmI,EAAc3T,GACtBgU,EAAWnI,EAAOL,GACxBF,KAAKuC,oBAAqBmG,EAAUjX,IAEpCkD,EAAO+T,EAAShG,kBAAmBjR,IAEvB6T,IAEXA,EAAoB3Q,EACfwN,GAAUA,EAAQQ,KAAMlR,GACxB2Q,GAAUA,EAAQO,KAAM+F,IAK9B,IAAMC,EAAU3I,KAAME,GACtBK,EAAMgC,oBAAqBoG,EAASlX,IAEpCkD,EAAOgU,EAAQjG,kBAAmBjR,IAEtB6T,IAEXA,EAAoB3Q,EACfwN,GAAUA,EAAQQ,KAAMgG,GACxBvG,GAAUA,EAAQO,KAAMlR,IAM/B,IAAM,IAAIiD,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAMkU,EAAMP,EAAc3T,GACpBmU,EAAMR,GAAgB3T,EAAI,GAAM,GACtC4T,EAAMvY,IAAKiQ,KAAM4I,GAAO5I,KAAM6I,IAC9B,IAAM,IAAI/B,EAAK,EAAGA,EAAK,EAAGA,IAAQ,CAEjC,IAAMgC,EAAMT,EAAcvB,GACpBiC,EAAMV,GAAgBvB,EAAK,GAAM,GACvCyB,EAAMxY,IAAKwQ,EAAOuI,GAAOvI,EAAOwI,IAEhChH,EAA+BuG,EAAOC,EAAO9W,EAAOyT,GAEpD,IAAMvQ,EAAOlD,EAAMiR,kBAAmBwC,GACjCvQ,EAAO2Q,IAEXA,EAAoB3Q,EACfwN,GAAUA,EAAQQ,KAAMlR,GACxB2Q,GAAUA,EAAQO,KAAMuC,KAQhC,OAAOtR,KAAK4R,KAAMF,IAtF8B,GCla3C,IAAM0D,EAAb,0CAEC,aAAuB,iDAAPjF,EAAO,yBAAPA,EAAO,uBAEtB,+BAAUA,KAELkF,eAAgB,EACrB,EAAKC,OAAS,IAAIC,EAAAA,QAClB,EAAKC,UAAY,IAAID,EAAAA,QACrB,EAAKlJ,OAAS,IAAIvH,MAAO,GAAIC,OAAOC,KAAK,kBAAM,IAAIvI,EAAAA,WACnD,EAAK4T,QAAU,IAAIvL,MAAO,GAAIC,OAAOC,KAAK,kBAAM,IAAIvI,EAAAA,WACpD,EAAK6T,UAAY,IAAIxL,MAAO,GAAIC,OAAOC,KAAK,kBAAM,IAAImH,KACtD,EAAKsJ,iBAAmB,IAAI3Q,MAAO,GAAIC,OAAOC,KAAK,kBAAM,IAAImH,KAC7D,EAAKqE,aAAc,EAXG,EAFxB,kCAiBC,SAAKjQ,EAAKC,EAAK8U,IAEd,kDAAW/U,EAAKC,GAChB4L,KAAKkJ,OAAOvG,KAAMuG,GAClBlJ,KAAKoE,aAAc,IArBrB,kBAyBC,SAAM7D,IAEL,mDAAYA,GACZP,KAAKkJ,OAAOvG,KAAMpC,EAAM2I,QACxBlJ,KAAKoE,aAAc,MA7BrB,GAAiCkF,EAAAA,MCD1B,SAASC,EAAa9W,EAAKiC,EAAG9B,EAAOoF,GAE3C,IAAMwR,EAAK/W,EAAIzB,EACTyY,EAAKhX,EAAIxB,EACTyY,EAAKjX,EAAIvB,EAEXyY,EAAKjV,EACLkV,EAAKlV,EAAI,EACToS,EAAKpS,EAAI,EACR9B,IAEJ+W,EAAK/W,EAAMC,KAAM6B,GACjBkV,EAAKhX,EAAMC,KAAM6B,EAAI,GACrBoS,EAAKlU,EAAMC,KAAM6B,EAAI,IAItB8U,EAAGxZ,EAAIgI,EAAInF,KAAM8W,GACjBH,EAAGvZ,EAAI+H,EAAI6R,KAAMF,GACjBH,EAAGtZ,EAAI8H,EAAI8R,KAAMH,GAEjBF,EAAGzZ,EAAIgI,EAAInF,KAAM+W,GACjBH,EAAGxZ,EAAI+H,EAAI6R,KAAMD,GACjBH,EAAGvZ,EAAI8H,EAAI8R,KAAMF,GAEjBF,EAAG1Z,EAAIgI,EAAInF,KAAMiU,GACjB4C,EAAGzZ,EAAI+H,EAAI6R,KAAM/C,GACjB4C,EAAGxZ,EAAI8H,EAAI8R,KAAMhD,GAIX,SAASiD,EACfhU,EACAC,EACAgU,EACAC,EACAC,EACAzO,EACA2H,GAKA,IAFA,IAAMxQ,EAAQoX,EAASpX,MACjBoF,EAAMgS,EAASlX,WAAWhD,SACtB4E,EAAIqB,EAAQoK,EAAInK,EAAQD,EAAQrB,EAAIyL,EAAGzL,IAKhD,GAHA6U,EAAanG,EAAc,EAAJ1O,EAAO9B,EAAOoF,GACrCoL,EAASgB,aAAc,EAElB6F,EAAwB7G,EAAU1O,EAAGwV,EAAWzO,GAEpD,OAAO,EAMT,OAAO,EDpBRuN,EAAYxI,UAAU2F,OAEd,WAON,IALA,IAAM+C,EAASlJ,KAAKkJ,OACd/U,EAAM6L,KAAK7L,IACXC,EAAM4L,KAAK5L,IAEX6L,EAASD,KAAKC,OACVjQ,EAAI,EAAGA,GAAK,EAAGA,IAExB,IAAM,IAAIC,EAAI,EAAGA,GAAK,EAAGA,IAExB,IAAM,IAAIC,EAAI,EAAGA,GAAK,EAAGA,IAAO,CAE/B,IACMia,EAAIlK,EADE,EAAajQ,EAAQ,EAAaC,EAAQ,EAAaC,GAEnEia,EAAEna,EAAIA,EAAIoE,EAAIpE,EAAImE,EAAInE,EACtBma,EAAEla,EAAIA,EAAImE,EAAInE,EAAIkE,EAAIlE,EACtBka,EAAEja,EAAIA,EAAIkE,EAAIlE,EAAIiE,EAAIjE,EAEtBia,EAAE/W,aAAc8V,GAWnB,IAHA,IAAMhF,EAAYlE,KAAKkE,UACjBD,EAAUjE,KAAKiE,QACfmG,EAASnK,EAAQ,GACbvL,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAMwD,EAAO+L,EAASvP,GAChB8R,EAAKtC,EAAWxP,GAEhB2V,EAAKpK,EADG,GAAKvL,GAGnBwD,EAAKuJ,WAAY2I,EAAQC,GACzB7D,EAAGhC,cAAetM,EAAM+H,GAIzB,IAAMoJ,EAAmBrJ,KAAKqJ,iBAC9BA,EAAkB,GAAIiB,mBAAoBrK,EAAQ,KAClDoJ,EAAkB,GAAIiB,mBAAoBrK,EAAQ,KAClDoJ,EAAkB,GAAIiB,mBAAoBrK,EAAQ,KAElDD,KAAKoJ,UAAUzG,KAAM3C,KAAKkJ,QAASqB,SACnCvK,KAAKoE,aAAc,GAMrB4E,EAAYxI,UAAUgK,cAAkB,WAEvC,IAAMC,EAAa,IAAI1K,EACvB,OAAO,SAAwBW,GAGzBV,KAAKoE,aAETpE,KAAKmG,SAIN,IAAMhS,EAAMuM,EAAIvM,IACVC,EAAMsM,EAAItM,IACV8P,EAAYlE,KAAKkE,UACjBD,EAAUjE,KAAKiE,QACfoF,EAAmBrJ,KAAKqJ,iBAI9B,GAFAoB,EAAWtW,IAAMA,EAAInE,EACrBya,EAAWrW,IAAMA,EAAIpE,EAChBqZ,EAAkB,GAAI3C,YAAa+D,GAAe,OAAO,EAI9D,GAFAA,EAAWtW,IAAMA,EAAIlE,EACrBwa,EAAWrW,IAAMA,EAAInE,EAChBoZ,EAAkB,GAAI3C,YAAa+D,GAAe,OAAO,EAI9D,GAFAA,EAAWtW,IAAMA,EAAIjE,EACrBua,EAAWrW,IAAMA,EAAIlE,EAChBmZ,EAAkB,GAAI3C,YAAa+D,GAAe,OAAO,EAE9D,IAAM,IAAI/V,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAMwD,EAAO+L,EAASvP,GAChB8R,EAAKtC,EAAWxP,GAEtB,GADA+V,EAAWhK,WAAYvI,EAAMwI,GACxB8F,EAAGE,YAAa+D,GAAe,OAAO,EAI5C,OAAO,GAvC+B,GA6CxCzB,EAAYxI,UAAUiF,mBAAuB,WAE5C,IAAMiF,EAAQ,IAAI5G,EACZ6G,EAAY,IAAIjS,MAAO,GACvBmN,EAAkB,IAAI9F,EACtB+F,EAAmB,IAAI/F,EACvBgG,EAAa,IAAI1V,EAAAA,QACvB,OAAO,SAA6B+S,GAE9BpD,KAAKoE,aAETpE,KAAKmG,SAIC/C,EAASY,mBAMJZ,EAASgB,aAEpBhB,EAAS+C,UANTuE,EAAM/H,KAAMS,GACZsH,EAAMvE,SACN/C,EAAWsH,GAQZ,IAAMxG,EAAYlE,KAAKkE,UACjBD,EAAUjE,KAAKiE,QAErB0G,EAAW,GAAMvH,EAASpS,EAC1B2Z,EAAW,GAAMvH,EAASnS,EAC1B0Z,EAAW,GAAMvH,EAASlS,EAE1B,IAAM,IAAIwD,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAM8R,EAAKtC,EAAWxP,GAChB+R,EAAKxC,EAASvP,GAEpB,GADAmR,EAAgBrB,cAAeiC,EAAIkE,GAC9BnE,EAAGE,YAAab,GAAoB,OAAO,EAOjD,IAHA,IAAM+E,EAAexH,EAASc,UACxB2G,EAAazH,EAASa,QACtBhE,EAASD,KAAKC,OACVvL,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAM8R,EAAKoE,EAAclW,GACnB+R,EAAKoE,EAAYnW,GAEvB,GADAmR,EAAgBrB,cAAeiC,EAAIxG,GAC9BuG,EAAGE,YAAab,GAAoB,OAAO,EAKjD,IAAM,IAAInR,EAAI,EAAGA,EAAI,EAAGA,IAGvB,IADA,IAAMmS,EAAM5C,EAASvP,GACXoS,EAAK,EAAGA,EAAK,EAAGA,IAAQ,CAEjC,IAAMC,EAAM8D,EAAY/D,GAIxB,GAHAf,EAAWiB,aAAcH,EAAKE,GAC9BlB,EAAgBrB,cAAeuB,EAAY4E,GAC3C7E,EAAiBtB,cAAeuB,EAAY9F,GACvC4F,EAAgBa,YAAaZ,GAAqB,OAAO,EAMhE,OAAO,GAvEoC,GA6E7CkD,EAAYxI,UAAU+B,oBAEd,SAA8B9Q,EAAO0Q,GAc3C,OAZKnC,KAAKoE,aAETpE,KAAKmG,SAINhE,EACEQ,KAAMlR,GACN2B,aAAc4M,KAAKoJ,WACnB0B,MAAO9K,KAAK7L,IAAK6L,KAAK5L,KACtBhB,aAAc4M,KAAKkJ,QAEd/G,GAMT6G,EAAYxI,UAAUgD,gBAAoB,WAEzC,IAAMtP,EAAS,IAAI7D,EAAAA,QACnB,OAAO,SAA0BoB,GAGhC,OADAuO,KAAKuC,oBAAqB9Q,EAAOyC,GAC1BzC,EAAMM,WAAYmC,IANe,GAY1C8U,EAAYxI,UAAUuK,cAAkB,WAEvC,IAAMC,EAAY,CAAE,IAAK,IAAK,KACxBC,EAAY,IAAIvS,MAAO,IAAKC,OAAOC,KAAK,kBAAM,IAAIsK,EAAAA,SAClDgI,EAAY,IAAIxS,MAAO,IAAKC,OAAOC,KAAK,kBAAM,IAAIsK,EAAAA,SAElD+B,EAAS,IAAI5U,EAAAA,QACb6U,EAAS,IAAI7U,EAAAA,QAGnB,OAAO,SAAwBqQ,GAAqD,IAAhDyK,EAAgD,uDAApC,EAAGhJ,EAAiC,uDAAvB,KAAMC,EAAiB,uDAAP,KAQ5E,GANKpC,KAAKoE,aAETpE,KAAKmG,SAIDnG,KAAKwK,cAAe9J,GAaxB,OAXKyB,GAAWC,KAEf1B,EAAI+H,UAAWvD,GACflF,KAAKuC,oBAAqB2C,EAAQD,GAClCvE,EAAI6B,oBAAqB0C,EAAQC,GAE5B/C,GAAUA,EAAQQ,KAAMsC,GACxB7C,GAAUA,EAAQO,KAAMuC,IAIvB,EAcR,IAVA,IAAMkG,EAAaD,EAAYA,EACzBhX,EAAMuM,EAAIvM,IACVC,EAAMsM,EAAItM,IACV6L,EAASD,KAAKC,OAIhBqF,EAAoB7Q,IAGdC,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAM2L,EAAIJ,EAAQvL,GAClBwQ,EAAOvC,KAAMtC,GAAIyK,MAAO3W,EAAKC,GAE7B,IAAMO,EAAO0L,EAAEqC,kBAAmBwC,GAClC,GAAKvQ,EAAO2Q,IAEXA,EAAoB3Q,EACfwN,GAAUA,EAAQQ,KAAMtC,GACxB+B,GAAUA,EAAQO,KAAMuC,GAExBvQ,EAAOyW,GAAa,OAAOxX,KAAK4R,KAAM7Q,GAQ7C,IADA,IAAIqB,EAAQ,EACFtB,EAAI,EAAGA,EAAI,EAAGA,IAEvB,IAAM,IAAIkV,EAAK,EAAGA,GAAM,EAAGA,IAE1B,IAAM,IAAI9C,EAAK,EAAGA,GAAM,EAAGA,IAAQ,CAElC,IAAMuE,GAAc3W,EAAI,GAAM,EACxB4W,GAAe5W,EAAI,GAAM,EAGzB9B,EAAQgX,GAAMyB,EAAYvE,GAAMwE,EAChCC,EAAS,GAAK7W,EAAIkV,GAAMyB,EAAYvE,GAAMwE,EAC1CE,EAAKvL,EAAQrN,GACbyP,EAAKpC,EAAQsL,GACbjD,EAAQ2C,EAAWjV,GACzBsS,EAAMvY,IAAKyb,EAAInJ,GAIf,IAAMoJ,EAAKT,EAAWtW,GAChBgX,EAAKV,EAAWK,GAChBM,EAAKX,EAAWM,GAChB/C,EAAQ2C,EAAWlV,GACnBwI,EAAQ+J,EAAM/J,MACdzH,EAAMwR,EAAMxR,IAElByH,EAAOiN,GAAOtX,EAAKsX,GACnBjN,EAAOkN,GAAO9B,EAAKzV,EAAKuX,GAAOtX,EAAKsX,GACpClN,EAAOmN,GAAO7E,EAAK3S,EAAKwX,GAAOvX,EAAKsX,GAEpC3U,EAAK0U,GAAOrX,EAAKqX,GACjB1U,EAAK2U,GAAO9B,EAAKzV,EAAKuX,GAAOtX,EAAKsX,GAClC3U,EAAK4U,GAAO7E,EAAK3S,EAAKwX,GAAOvX,EAAKsX,GAElC1V,IASH,IAAM,IAAIhG,EAAI,EAAGA,GAAK,EAAGA,IAExB,IAAM,IAAIC,EAAI,EAAGA,GAAK,EAAGA,IAExB,IAAM,IAAIC,EAAI,EAAGA,GAAK,EAAGA,IAAO,CAE/BgV,EAAOlV,EAAIA,EAAIoE,EAAIpE,EAAImE,EAAInE,EAC3BkV,EAAOjV,EAAIA,EAAImE,EAAInE,EAAIkE,EAAIlE,EAC3BiV,EAAOhV,EAAIA,EAAIkE,EAAIlE,EAAIiE,EAAIjE,EAE3B8P,KAAKuC,oBAAqB2C,EAAQD,GAClC,IAAMtQ,EAAOuQ,EAAOxC,kBAAmBuC,GACvC,GAAKtQ,EAAO2Q,IAEXA,EAAoB3Q,EACfwN,GAAUA,EAAQQ,KAAMsC,GACxB7C,GAAUA,EAAQO,KAAMuC,GAExBvQ,EAAOyW,GAAa,OAAOxX,KAAK4R,KAAM7Q,GAU/C,IAAM,IAAID,EAAI,EAAGA,EAAI,GAAIA,IAGxB,IADA,IAAMwM,EAAK+J,EAAWvW,GACZoS,EAAK,EAAGA,EAAK,GAAIA,IAAQ,CAElC,IAAM3F,EAAK+J,EAAWpE,GACtB/E,EAA+Bb,EAAIC,EAAI8D,EAAQC,GAC/C,IAAMvQ,EAAOsQ,EAAOvC,kBAAmBwC,GACvC,GAAKvQ,EAAO2Q,IAEXA,EAAoB3Q,EACfwN,GAAUA,EAAQQ,KAAMsC,GACxB7C,GAAUA,EAAQO,KAAMuC,GAExBvQ,EAAOyW,GAAa,OAAOxX,KAAK4R,KAAM7Q,GAQ9C,OAAOf,KAAK4R,KAAMF,IA9JoB,GE5PjC,IAAMsG,GAAb,WAEC,WAAaC,IAAkB,eAE9B7L,KAAK8L,iBAAmBD,EACxB7L,KAAK+L,YAAc,GALrB,2CASC,WAEC,IAAMC,EAAahM,KAAK+L,YACxB,OAA2B,IAAtBC,EAAWlS,OAERkG,KAAK8L,mBAILE,EAAWC,QAlBrB,8BAwBC,SAAkBC,GAEjBlM,KAAK+L,YAAYhZ,KAAMmZ,OA1BzB,KCAO,SAASC,GAASC,EAAKjN,GAE7B,OAAmC,QAA5BA,EAAaiN,EAAM,IAIpB,SAASC,GAAQC,EAAKpN,GAE5B,OAAOA,EAAaoN,EAAM,GAIpB,SAASC,GAAOH,EAAKjN,GAE3B,OAAOA,EAAaiN,EAAM,IAIpB,SAASI,GAAWF,GAE1B,OAAOA,EAAM,EAIP,SAASG,GAAYH,EAAKpN,GAEhC,OAAOA,EAAaoN,EAAM,GCf3B,IAAMzd,GAAc,IAAIya,EAAAA,KAClBoD,GAAkB,IAAIrc,EAAAA,QACtB2a,GAAY,CAAE,IAAK,IAAK,KAEvB,SAAS2B,GAAS3Y,EAAagW,EAAU7Y,EAAML,EAAK8b,GAE1D,IAAIC,EAA4B,EAAd7Y,EAAiBiL,EAAe6N,GAAe3N,EAAc4N,GAAc7N,EAAc8N,GAG3G,GADeb,GAASU,EAAa1N,GACvB,EZlBR,SAAwB3M,EAAKrB,EAAML,EAAKiF,EAAQC,EAAOtD,GAE7D,IAAM,IAAIgC,EAAIqB,EAAQgB,EAAMhB,EAASC,EAAOtB,EAAIqC,EAAKrC,IAEpDnC,EAAcC,EAAKrB,EAAML,EAAK4D,EAAGhC,GYmBjCua,CAAejD,EAAU7Y,EAAML,EAHhBub,GAAQrY,EAAakL,GACtBqN,GAAOM,EAAa1N,GAEiByN,OAE7C,CAEN,IAAMM,EAAYV,GAAWxY,GACxBmZ,GAAcD,EAAWjO,EAAcnO,EAAK4b,KAEhDC,GAASO,EAAWlD,EAAU7Y,EAAML,EAAK8b,GAI1C,IAAMQ,EAAaX,GAAYzY,EAAakL,GACvCiO,GAAcC,EAAYnO,EAAcnO,EAAK4b,KAEjDC,GAASS,EAAYpD,EAAU7Y,EAAML,EAAK8b,IAQtC,SAASS,GAAcrZ,EAAagW,EAAU7Y,EAAML,GAE1D,IAAI+b,EAA4B,EAAd7Y,EAAiBiL,EAAe6N,GAAe3N,EAAc4N,GAAc7N,EAAc8N,GAG3G,GADeb,GAASU,EAAa1N,GAKpC,OZ5CK,SAA8B3M,EAAKrB,EAAML,EAAKiF,EAAQC,GAI5D,IAFA,IAAIrB,EAAOF,IACP6Y,EAAM,KACA5Y,EAAIqB,EAAQgB,EAAMhB,EAASC,EAAOtB,EAAIqC,EAAKrC,IAAO,CAE3D,IAAMrD,EAAekB,EAAcC,EAAKrB,EAAML,EAAK4D,GAC9CrD,GAAgBA,EAAaQ,SAAW8C,IAE5C2Y,EAAMjc,EACNsD,EAAOtD,EAAaQ,UAMtB,OAAOyb,EY4BCC,CAAqBvD,EAAU7Y,EAAML,EAF7Bub,GAAQrY,EAAakL,GACtBqN,GAAOM,EAAa1N,IAOlC,IAMIqO,EAAIC,EANFxR,EDhCD,SAAqBqQ,EAAKpN,GAEhC,OAAOA,EAAaoN,EAAM,GC8BPoB,CAAY1Z,EAAakL,GACrCyO,EAAU3C,GAAW/O,GAErB2R,EADS9c,EAAI+c,UAAWF,IACA,EAIzBC,GAEJJ,EAAKhB,GAAWxY,GAChByZ,EAAKhB,GAAYzY,EAAakL,KAI9BsO,EAAKf,GAAYzY,EAAakL,GAC9BuO,EAAKjB,GAAWxY,IAIjB,IACM8Z,EADiBX,GAAcK,EAAIvO,EAAcnO,EAAK4b,IAC1BW,GAAcG,EAAIxD,EAAU7Y,EAAML,GAAQ,KAI5E,GAAKgd,EAAW,CAIf,IAAMrc,EAAQqc,EAASrc,MAAOkc,GAK9B,GAJkBC,EACjBnc,GAASwN,EAAcwO,EAAKxR,GAC5BxK,GAASwN,EAAcwO,EAAKxR,EAAY,GAIxC,OAAO6R,EAQT,IACMC,EADiBZ,GAAcM,EAAIxO,EAAcnO,EAAK4b,IAC1BW,GAAcI,EAAIzD,EAAU7Y,EAAML,GAAQ,KAE5E,OAAKgd,GAAYC,EAETD,EAASjc,UAAYkc,EAASlc,SAAWic,EAAWC,EAIpDD,GAAYC,GAAY,KAQ3B,IAAMC,GAAc,WAE1B,IAAIC,EAAOC,EACLC,EAAW,GACXC,EAAU,IAAIxC,IAAe,kBAAM,IAAItC,EAAAA,QAE7C,OAAO,WAEN2E,EAAQG,EAAQC,eAChBH,EAAQE,EAAQC,eAChBF,EAASpb,KAAMkb,EAAOC,GAEtB,IAAM9M,EAASkN,EAAiB,WAAjB,aAEfF,EAAQG,iBAAkBN,GAC1BG,EAAQG,iBAAkBL,GAC1BC,EAASlC,MACTkC,EAASlC,MAET,IAAMnS,EAASqU,EAASrU,OAQxB,OAPKA,EAAS,IAEboU,EAAQC,EAAUrU,EAAS,GAC3BmU,EAAQE,EAAUrU,EAAS,IAIrBsH,GAIR,SAASkN,EACRta,EACAgW,EACAwE,EACAC,GAIC,IAHDC,EAGC,uDAHe,KAChBC,EAEC,uDAFqB,EACtBlT,EACC,uDADO,EAKR,SAASmT,EAAe5a,GAKvB,IAHA,IAAI6Y,EAA4B,EAAd7Y,EAAiBmL,EAAc4N,GAAc7N,EAAc8N,IAGnEb,GAASU,EAAa1N,IAG/B0N,EAA4B,GAD5B7Y,EAAcwY,GAAWxY,IAK1B,OAAOqY,GAAQrY,EAAakL,GAI7B,SAAS2P,EAAmB7a,GAK3B,IAHA,IAAI6Y,EAA4B,EAAd7Y,EAAiBmL,EAAc4N,GAAc7N,EAAc8N,IAGnEb,GAASU,EAAa1N,IAI/B0N,EAA4B,GAD5B7Y,EAAcyY,GAAYzY,EAAakL,IAMxC,OAAOmN,GAAQrY,EAAakL,GAAgBqN,GAAOM,EAAa1N,GAIjE,IAAI0N,EAA4B,EAAd7Y,EAAiBiL,EAAe6N,GAAe3N,EAAc4N,GAAc7N,EAAc8N,GAErGpN,EAASuM,GAASU,EAAa1N,GACrC,GAAKS,EAAS,CAEb,IAAM7J,EAASsW,GAAQrY,EAAakL,GAC9BlJ,EAAQuW,GAAOM,EAAa1N,GAElC,OADApL,EAAiCC,EAAeiL,EAAcgP,GACvDQ,EAAqB1Y,EAAQC,GAAO,EAAOyF,EAAOkT,EAAsB3a,EAAaia,GAI5F,IAKIa,EAAQC,EACRC,EAAMC,EANJnX,EAAO0U,GAAWxY,GAClB+D,EAAQ0U,GAAYzY,EAAakL,GACnCsO,EAAK1V,EACL2V,EAAK1V,EAIT,GAAK2W,IAGJO,EAAOf,EAGPna,EAAiCyZ,EAAMvO,EAJvC+P,EAAOf,GAKPla,EAAiC0Z,EAAMxO,EAAcgQ,GAErDH,EAASJ,EAAeM,IACxBD,EAASL,EAAeO,IAEVH,GAAS,CAEtBtB,EAAKzV,EACL0V,EAAK3V,EAEL,IAAMoX,EAAOJ,EACbA,EAASC,EACTA,EAASG,EAETF,EAAOC,EAQFD,GAGNjb,EAAiCyZ,EAAMvO,EADvC+P,EAAOf,GAKR,IAGIkB,EAHEC,EAAWjD,GAAc,EAALqB,EAAQrO,GAC5BkQ,EAAiBb,EAAsBQ,EAAMI,EAAUN,EAAQrT,EAAQ,EAAGkT,EAAsBnB,GAGtG,GX1PsB,IW0PjB6B,EAA+B,CAEnC,IAAMtZ,EAAS6Y,EAAepB,GACxBzW,EAAM8X,EAAmBrB,GACzBxX,EAAQe,EAAMhB,EAEpBoZ,EAAkBV,EAAqB1Y,EAAQC,GAAO,EAAMyF,EAAQ,EAAGkT,EAAsBnB,EAAIwB,QAIjGG,EACCE,GACAf,EACCd,EACAxD,EACAwE,EACAC,EACAC,EACAC,EACAlT,EAAQ,GAKX,GAAK0T,EAAkB,OAAO,EAK9Bpb,EAAiC0Z,EAAMxO,EADvCgQ,EAAOf,GAGP,IAGIoB,EAHEC,EAAWpD,GAAc,EAALsB,EAAQtO,GAC5BqQ,EAAiBhB,EAAsBS,EAAMM,EAAUR,EAAQtT,EAAQ,EAAGkT,EAAsBlB,GAGtG,GX7RsB,IW6RjB+B,EAA+B,CAEnC,IAAMzZ,EAAS6Y,EAAenB,GACxB1W,EAAM8X,EAAmBpB,GACzBzX,EAAQe,EAAMhB,EAEpBuZ,EAAkBb,EAAqB1Y,EAAQC,GAAO,EAAMyF,EAAQ,EAAGkT,EAAsBlB,EAAIwB,QAIjGK,EACCE,GACAlB,EACCb,EACAzD,EACAwE,EACAC,EACAC,EACAC,EACAlT,EAAQ,GAKX,QAAK6T,GAnMmB,GA6MdG,GAAuB,WAEnC,IAAMrM,EAAW,IAAIU,EACf4L,EAAY,IAAI5L,EAChB6L,EAAc,IAAIxG,EAAAA,QAElByG,EAAM,IAAI5G,EACV6G,EAAO,IAAI7G,EAEjB,OAAO,SAASyG,EAAoBzb,EAAagW,EAAU8F,EAAeC,GAAkC,IAAnBC,EAAmB,uDAAP,KAEhGnD,EAA4B,EAAd7Y,EAAiBiL,EAAe6N,GAAe3N,EAAc4N,GAAc7N,EAAc8N,GAExF,OAAdgD,IAEGF,EAAcjhB,aAEpBihB,EAAcG,qBAIfL,EAAI7f,IAAK+f,EAAcjhB,YAAYsF,IAAK2b,EAAcjhB,YAAYuF,IAAK2b,GACvEC,EAAYJ,GAIb,IAAMhQ,EAASuM,GAASU,EAAa1N,GACrC,IAAKS,EAmFE,CAEN,IAAM9H,EAAO9D,EAAc,EACrB+D,EAAQmH,EAAalL,EAAc,GAEzCD,EAAiC+D,EAAQmH,EAAcpQ,IACvD,IAAMqhB,EACLF,EAAUxF,cAAe3b,KACzB4gB,EAAoB3X,EAAMkS,EAAU8F,EAAeC,EAAeC,GAEnE,GAAKE,EAAmB,OAAO,EAE/Bnc,EAAiCgE,EAASkH,EAAcpQ,IACxD,IAAMshB,EACLH,EAAUxF,cAAe3b,KACzB4gB,EAAoB1X,EAAOiS,EAAU8F,EAAeC,EAAeC,GAEpE,QAAKG,EAlGL,IAAMC,EAAepG,EACfqG,EAAYD,EAAaxd,MACzB0d,EAAUF,EAAatd,WAAWhD,SAElC8C,EAAQkd,EAAcld,MACtBoF,EAAM8X,EAAchd,WAAWhD,SAE/BiG,EAASsW,GAAQrY,EAAakL,GAC9BlJ,EAAQuW,GAAOM,EAAa1N,GAOlC,GAFAwQ,EAAYhN,KAAMoN,GAAgBxF,SAE7BuF,EAAcS,WAAa,CAE/Bxc,EAAiCC,EAAeiL,EAAc4Q,GAC9DA,EAAK3G,OAAOvG,KAAMgN,GAClBE,EAAKzL,aAAc,EAEnB,IAAMkJ,EAAMwC,EAAcS,WAAWvC,UAAW,CAE/CwC,iBAAkB,SAAA9P,GAAG,OAAImP,EAAKrF,cAAe9J,IAE7C+E,mBAAoB,SAAAhT,GAEnBA,EAAIzB,EAAEoC,aAAc2c,GACpBtd,EAAIxB,EAAEmC,aAAc2c,GACpBtd,EAAIvB,EAAEkC,aAAc2c,GACpBtd,EAAI2R,aAAc,EAElB,IAAM,IAAI1P,EAAa,EAATqB,EAAYoK,EAAyB,GAAnBnK,EAAQD,GAAcrB,EAAIyL,EAAGzL,GAAK,EAKjE,GAFA6U,EAAamG,EAAWhb,EAAG2b,EAAWC,GACtCZ,EAAUtL,aAAc,EACnB3R,EAAIgT,mBAAoBiK,GAE5B,OAAO,EAMT,OAAO,KAMT,OAAOpC,EAIP,IAAM,IAAI5Y,EAAa,EAATqB,EAAYoK,EAAMnK,EAAiB,EAATD,EAAcrB,EAAIyL,EAAGzL,GAAK,EAAI,CAGrE6U,EAAanG,EAAU1O,EAAG2b,EAAWC,GACrClN,EAASpS,EAAEoC,aAAcuc,GACzBvM,EAASnS,EAAEmC,aAAcuc,GACzBvM,EAASlS,EAAEkC,aAAcuc,GACzBvM,EAASgB,aAAc,EAEvB,IAAM,IAAI0C,EAAK,EAAG3F,EAAKvO,EAAMoD,MAAO8Q,EAAK3F,EAAI2F,GAAM,EAKlD,GAHAyC,EAAamG,EAAW5I,EAAIlU,EAAOoF,GACnC0X,EAAUtL,aAAc,EAEnBhB,EAASqC,mBAAoBiK,GAEjC,OAAO,IApGsB,GAyIpC,SAASvC,GAAcnZ,EAAaC,EAAOnD,EAAKoD,GAG/C,OADAH,EAAYC,EAAaC,EAAOpF,IACzBiC,EAAI2f,aAAc5hB,GAAaqF,GAIvC,IACIwc,GACA5D,GACAC,GACAC,GAJE2D,GAAc,GAKb,SAASC,GAAWrR,GAErBmR,IAEJC,GAAY5d,KAAM2d,IAInBA,GAAcnR,EACduN,GAAgB,IAAIjU,aAAc0G,GAClCwN,GAAe,IAAIlQ,YAAa0C,GAChCyN,GAAe,IAAIpQ,YAAa2C,GAI1B,SAASsR,KAEfH,GAAc,KACd5D,GAAgB,KAChBC,GAAe,KACfC,GAAe,KAEV2D,GAAY7W,QAEhB8W,GAAWD,GAAY1E,OClezB,IAAM6E,GAAkBC,OAAQ,wBAE1BC,GAAuB,IAAI1H,EAAAA,KAC3B2H,GAAwB,IAAI3H,EAAAA,KAC5B4H,GAA6B,IAAI/H,EAAAA,QACjCyG,GAAsB,IAAI5G,EAC1B6G,GAAuB,IAAI7G,EAC3BkG,GAAuB,IAAI7e,EAAAA,QAC3B4R,GAAwB,IAAI5R,EAAAA,QAC5B6R,GAAwB,IAAI7R,EAAAA,QAC5B8gB,GAAwB,IAAI9gB,EAAAA,QAC5B+gB,GAAwB,IAAI/gB,EAAAA,QAC5BghB,GAA0B,IAAI/H,EAAAA,KAC9BgI,GAA+B,IAAI1F,IAAe,kBAAM,IAAI9H,KAErDyN,GAAb,WA4FC,WAAavH,GAAyB,IAAf9O,EAAe,uDAAL,GAEhC,IAFqC,gBAE9B8O,EAASwH,iBAEf,MAAM,IAAI1R,MAAO,iDAEX,GAAKkK,EAASpX,OAASoX,EAASpX,MAAM2K,6BAE5C,MAAM,IAAIuC,MAAO,iFAsBlB,IAjBA5E,EAAUuW,OAAOC,QAAP,QAETtY,SZ3ImB,EY4InBuC,SAAU,GACVE,YAAa,GACbD,SAAS,EACTa,sBAAsB,EACtBkV,gBAAgB,EAChBtW,WAAY,MAKVyV,IAAmB,GAEnB5V,IAEUuB,sBAAqD,qBAAtBC,kBAE3C,MAAM,IAAIoD,MAAO,gDAIlBE,KAAK4R,OAAS,KACP1W,EAAS4V,MAEf9Q,KAAK4R,OAAS5S,EAAiBgL,EAAU9O,IAElC8O,EAASnb,aAAeqM,EAAQyW,iBAEtC3H,EAASnb,YAAcmR,KAAK6R,eAAgB,IAAIvI,EAAAA,QAQlDtJ,KAAKgK,SAAWA,EA/IlB,oCAmJC,WAA4B,IAArB8H,EAAqB,uDAAP,KAEfA,GAAepZ,MAAMqZ,QAASD,KAElCA,EAAc,IAAIxT,IAAKwT,IAIxB,IAcIvS,EAAQL,EAAaC,EAAaF,EAdhC+K,EAAWhK,KAAKgK,SAChBgI,EAAWhI,EAASpX,MAAMqB,MAC1BiJ,EAAU8M,EAASlX,WAAWhD,SAC9BqN,EAASD,EAAQjJ,MAGjBoJ,EAAeH,EAAQnH,QAAU,EACnCuH,EAAS,EACRJ,EAAQK,+BAEZD,EAASJ,EAAQM,KAAKF,QAOvB,IAFA,IAAImC,EAAa,EACXvB,EAAQ8B,KAAK4R,OACTld,EAAI,EAAGyL,EAAIjC,EAAMpE,OAAQpF,EAAIyL,EAAGzL,IAEzC6K,EAASrB,EAAOxJ,GAChBwK,EAAc,IAAItC,YAAa2C,GAC/BJ,EAAc,IAAItC,YAAa0C,GAC/BN,EAAe,IAAIpG,aAAc0G,GAEjC0S,EAAW,EAAGxS,GACdA,GAAcF,EAAO2S,WAItB,SAASD,EAAWE,EAAa1S,GAA4B,IAAhB2S,EAAgB,wDAEtDC,EAA4B,EAAdF,EACdvS,EAAST,EAAakT,EAAc,MAAS3e,EACnD,GAAKkM,EAAS,CAWb,IATA,IAAM7J,EAASmJ,EAAaiT,EAAc,GACpCnc,EAAQmJ,EAAakT,EAAc,IAErCnc,EAAOzB,IACP0B,EAAO1B,IACP2B,EAAO3B,IACP4B,GAAS5B,IACT6B,GAAS7B,IACT8B,GAAS9B,IACHC,EAAI,EAAIqB,EAAQoK,EAAI,GAAMpK,EAASC,GAAStB,EAAIyL,EAAGzL,IAAO,CAEnE,IAAM9B,EAAQof,EAAUtd,GAAM4I,EAASD,EACjCrN,EAAImN,EAAQvK,EAAQ,GACpB3C,EAAIkN,EAAQvK,EAAQ,GACpB1C,EAAIiN,EAAQvK,EAAQ,GAErB5C,EAAIkG,IAAOA,EAAOlG,GAClBA,EAAIqG,IAAOA,EAAOrG,GAElBC,EAAIkG,IAAOA,EAAOlG,GAClBA,EAAIqG,IAAOA,EAAOrG,GAElBC,EAAIkG,IAAOA,EAAOlG,GAClBA,EAAIqG,IAAOA,EAAOrG,GAIxB,OACC+O,EAAckT,EAAc,KAAQjc,GACpC+I,EAAckT,EAAc,KAAQhc,GACpC8I,EAAckT,EAAc,KAAQ/b,GAEpC6I,EAAckT,EAAc,KAAQ9b,GACpC4I,EAAckT,EAAc,KAAQ7b,GACpC2I,EAAckT,EAAc,KAAQ5b,KAGpC0I,EAAckT,EAAc,GAAMjc,EAClC+I,EAAckT,EAAc,GAAMhc,EAClC8I,EAAckT,EAAc,GAAM/b,EAElC6I,EAAckT,EAAc,GAAM9b,EAClC4I,EAAckT,EAAc,GAAM7b,EAClC2I,EAAckT,EAAc,GAAM5b,GAE3B,GAUR,IAAMuB,EAAOqa,EAAc,EACrBpa,EAAQmH,EAAaiT,EAAc,GAInCG,EAAaxa,EAAO2H,EACpB8S,EAAcxa,EAAQ0H,EACxB+S,EAAgBJ,EAChBK,GAAe,EACfC,GAAgB,EAEfZ,EAIGU,IAENC,EAAeX,EAAYa,IAAKL,GAChCI,EAAgBZ,EAAYa,IAAKJ,GACjCC,GAAkBC,IAAkBC,IAMrCD,GAAe,EACfC,GAAgB,GAIjB,IAAME,EAAeJ,GAAiBC,EAChCI,EAAgBL,GAAiBE,EAEnCI,GAAa,EACZF,IAEJE,EAAab,EAAWna,EAAM2H,EAAY+S,IAI3C,IAAIO,GAAc,EACbF,IAEJE,EAAcd,EAAWla,EAAO0H,EAAY+S,IAI7C,IAAMQ,EAAYF,GAAcC,EAChC,GAAKC,EAEJ,IAAM,IAAIte,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,IAAMue,EAAQnb,EAAOpD,EACfwe,EAASnb,EAAQrD,EACjBye,EAAelU,EAAcgU,GAC7BG,EAAenU,EAAcgU,EAAQ,GACrCI,EAAgBpU,EAAciU,GAC9BI,EAAgBrU,EAAciU,EAAS,GAE7CjU,EAAckT,EAAczd,GAAMye,EAAeE,EAAgBF,EAAeE,EAChFpU,EAAckT,EAAczd,EAAI,GAAM0e,EAAeE,EAAgBF,EAAeE,EAMtF,OAAON,KAvTX,sBA+TC,SAAUO,GAA0B,IAAhBC,EAAgB,uDAAJ,EAEzBjU,EAASS,KAAK4R,OAAQ4B,GACtBtU,EAAc,IAAItC,YAAa2C,GAC/BJ,EAAc,IAAItC,YAAa0C,GAGrC,SAAS0S,EAAWE,GAAyB,IAAZ1W,EAAY,uDAAJ,EAElC4W,EAA4B,EAAdF,EACdvS,EAAST,EAAakT,EAAc,MAAS3e,EACnD,GAAKkM,EAAS,CAEb,IAAM7J,EAASmJ,EAAaiT,EAAc,GACpCnc,EAAQmJ,EAAakT,EAAc,IACzCkB,EAAU9X,EAAOmE,EAAQ,IAAI/G,aAAc0G,EAAsB,EAAd4S,EAAiB,GAAKpc,EAAQC,OAE3E,CAGN,IAAM8B,EAAOqa,EAAc1e,EACrBsE,EAAQmH,EAAaiT,EAAc,GACnClW,EAAYiD,EAAaiT,EAAc,GACvCsB,EAAgBF,EAAU9X,EAAOmE,EAAQ,IAAI/G,aAAc0G,EAAsB,EAAd4S,EAAiB,GAAKlW,GAExFwX,IAENxB,EAAWna,EAAM2D,EAAQ,GACzBwW,EAAWla,EAAO0D,EAAQ,KAvB7BwW,EAAW,KApUb,qBAsWC,SAASnhB,GAUR,IAV0C,IAA7B4iB,EAA6B,uDAAZC,EAAAA,UAExBzV,EAAQ8B,KAAK4R,OACb5H,EAAWhK,KAAKgK,SAChB4C,EAAa,GACbgH,EAAaF,EAAeE,WAC5BC,EAAkBnb,MAAMqZ,QAAS2B,GAEjCtV,EAAS4L,EAAS5L,OAClBjN,EAAOyiB,EAAaF,EAAeviB,KAAOuiB,EACtChf,EAAI,EAAGyL,EAAIjC,EAAMpE,OAAQpF,EAAIyL,EAAGzL,IAAO,CAEhD,IAAMof,EAAeD,EAAkBH,EAAgBtV,EAAQ1J,GAAIrC,eAAgBlB,KAAOA,EACpF4iB,EAAanH,EAAW9S,OAM9B,GAJA8W,GAAW1S,EAAOxJ,IAClBiY,GAAS,EAAG3C,EAAU8J,EAAchjB,EAAK8b,GACzCiE,KAEKgD,EAGJ,IADA,IAAMxhB,EAAgB+L,EAAQ1J,GAAIrC,cACxB2hB,EAAID,EAAYE,EAAKrH,EAAW9S,OAAQka,EAAIC,EAAID,IAEzDpH,EAAYoH,GAAI7hB,KAAKE,cAAgBA,EAQxC,OAAOua,IAtYT,0BA0YC,SAAc9b,GAWb,IAX+C,IAA7B4iB,EAA6B,uDAAZC,EAAAA,UAE7BzV,EAAQ8B,KAAK4R,OACb5H,EAAWhK,KAAKgK,SAChB4J,EAAaF,EAAeE,WAC5BC,EAAkBnb,MAAMqZ,QAAS2B,GAEnCQ,EAAgB,KAEd9V,EAAS4L,EAAS5L,OAClBjN,EAAOyiB,EAAaF,EAAeviB,KAAOuiB,EACtChf,EAAI,EAAGyL,EAAIjC,EAAMpE,OAAQpF,EAAIyL,EAAGzL,IAAO,CAEhD,IAAMof,EAAeD,EAAkBH,EAAgBtV,EAAQ1J,GAAIrC,eAAgBlB,KAAOA,EAE1Fyf,GAAW1S,EAAOxJ,IAClB,IAAM0M,EAASiM,GAAc,EAAGrD,EAAU8J,EAAchjB,GACxD+f,KAEe,MAAVzP,IAAqC,MAAjB8S,GAAyB9S,EAAOvP,SAAWqiB,EAAcriB,YAEjFqiB,EAAgB9S,EACXyS,IAEJzS,EAAOjP,KAAKE,cAAgB+L,EAAQ1J,GAAIrC,gBAQ3C,OAAO6hB,IA1aT,gCA8aC,SAAoBpE,EAAeqE,GAElC,IAF+C,EAEzCnK,EAAWhK,KAAKgK,SAClB5I,GAAS,EAHkC,UAI3BpB,KAAK4R,QAJsB,IAI/C,IAAK,EAAL,qBAAkC,CAMjC,GAJAhB,GAFiC,SAGjCxP,EAASqO,GAAoB,EAAGzF,EAAU8F,EAAeqE,GACzDtD,KAEKzP,EAEJ,OAZ6C,8BAkB/C,OAAOA,IAhcT,uBAocC,SAAWgT,EAAWC,EAAyBC,GAE9C,IAAMtK,EAAWhK,KAAKgK,SACtB,GAAKoK,aAAqBG,SAAW,CAEpC,GAAKF,EAA0B,CAI9B,IAAMG,EAAuBH,EAC7BA,EAA0B,SAAE5hB,EAAKG,EAAOsX,EAAWzO,GAElD,IAAMgZ,EAAa,EAAR7hB,EACX,OAAO4hB,EAAsB/hB,EAAKgiB,EAAIA,EAAK,EAAGA,EAAK,EAAGvK,EAAWzO,IAOnE2Y,EAAY,CAEXM,oBAAqBJ,EACrB9D,iBAAkB4D,EAClB3O,mBAAoB4O,EACpBM,gBAAiB,MAIlB5Z,QAAQC,KAAM,4IAIf,IAAMoI,EAAWkO,GAAajD,eAC9B,EAKI+F,EAJHM,EADD,EACCA,oBACAlE,EAFD,EAECA,iBACAmE,EAHD,EAGCA,gBACAlP,EAJD,EAICA,mBAGD,GAAKkP,GAAmBlP,EAAqB,CAE5C,IAAMmP,EAA0BD,EAChCA,EAAkB,SAAE5e,EAAQC,EAAOkU,EAAWzO,EAAOoZ,GAEpD,QAAOD,EAAyB7e,EAAQC,EAAOkU,EAAWzO,EAAOoZ,IAEzD9K,EAAsBhU,EAAQC,EAAOgU,EAAUvE,EAAoByE,EAAWzO,EAAO2H,SAQjFuR,IAIZA,EAFIlP,EAEc,SAAE1P,EAAQC,EAAOkU,EAAWzO,GAE7C,OAAOsO,EAAsBhU,EAAQC,EAAOgU,EAAUvE,EAAoByE,EAAWzO,EAAO2H,IAM3E,SAAErN,EAAQC,EAAOkU,GAElC,OAAOA,IAQV,IA9EgE,EA8E5D9I,GAAS,EACT3B,EAAa,EA/E+C,UAgF5CO,KAAK4R,QAhFuC,IAgFhE,IAAK,EAAL,qBAAkC,KAAtB9S,EAAsB,QAMjC,GAJA8R,GAAW9R,GACXsC,EAAS4M,GAAW,EAAGhE,EAAUwG,EAAkBmE,EAAiBD,EAAqBjV,GACzFoR,KAEKzP,EAEJ,MAID3B,GAAcX,EAAKoT,YA5F4C,8BAkGhE,OAFAZ,GAAa/C,iBAAkBnL,GAExBhC,IAtiBT,qBA0iBC,SAAS0T,EAAUC,EAAeX,GAKjC,IACCY,EAEGZ,EAFHY,iBACAC,EACGb,EADHa,oBAGKC,EAAYlV,KAAKgK,SAASpX,MAC1BuiB,EAAenV,KAAKgK,SAASlX,WAAWhD,SAExCslB,EAAiBN,EAAS9K,SAASpX,MACnCyiB,EAAoBP,EAAS9K,SAASlX,WAAWhD,SAEvDohB,GAAWvO,KAAMoS,GAAgBxK,SAEjC,IAAMnH,EAAWkO,GAAajD,eACxBqB,EAAY4B,GAAajD,eAE/B,GAAK4G,EAAsB,KAEjBK,EAAT,SAAqCC,EAASpO,EAAQqO,EAAS5N,EAAQ6N,EAAQC,EAAQC,EAAQpK,GAE9F,IAAM,IAAIzE,EAAK0O,EAASrU,EAAKqU,EAAU5N,EAAQd,EAAK3F,EAAI2F,IAAQ,CAE/DyC,EAAamG,EAAgB,EAAL5I,EAAQsO,EAAgBC,GAChD3F,EAAU1e,EAAEoC,aAAc2hB,GAC1BrF,EAAUze,EAAEmC,aAAc2hB,GAC1BrF,EAAUxe,EAAEkC,aAAc2hB,GAC1BrF,EAAUtL,aAAc,EAExB,IAAM,IAAIwF,EAAK2L,EAASrU,EAAKqU,EAAUpO,EAAQyC,EAAK1I,EAAI0I,IAKvD,GAHAL,EAAanG,EAAe,EAALwG,EAAQsL,EAAWC,GAC1C/R,EAASgB,aAAc,EAElB6Q,EAAqB7R,EAAUsM,EAAW9F,EAAI9C,EAAI2O,EAAQC,EAAQC,EAAQpK,GAE9E,OAAO,EAQV,OAAO,GAIR,GAAKyJ,EAAmB,CAEvB,IAAMY,EAA2BZ,EACjCA,EAAmB,SAAWO,EAASpO,EAAQqO,EAAS5N,EAAQ6N,EAAQC,EAAQC,EAAQpK,GAEvF,QAAOqK,EAA0BL,EAASpO,EAAQqO,EAAS5N,EAAQ6N,EAAQC,EAAQC,EAAQpK,IAEnF+J,EAA4BC,EAASpO,EAAQqO,EAAS5N,EAAQ6N,EAAQC,EAAQC,EAAQpK,SAU/FyJ,EAAmBM,EAMrBR,EAASjD,eAAgBZ,IACzBA,GAAM7d,aAAc2hB,GACpB,IAAM3T,EAASpB,KAAKgO,UAAW,CAE9BwC,iBAAkB,SAAA9P,GAAG,OAAIuQ,GAAMzG,cAAe9J,IAE9CiU,gBAAiB,SAAEY,EAASpO,EAAQ+C,EAAWuL,EAAQI,EAAYnV,GAIlE,OAFAsQ,GAAKrO,KAAMjC,GACXsQ,GAAK5d,aAAc8d,IACZ4D,EAAS9G,UAAW,CAE1BwC,iBAAkB,SAAA9P,GAAG,OAAIsQ,GAAKxG,cAAe9J,IAE7CiU,gBAAiB,SAAEa,EAAS5N,EAAQsC,EAAWyL,EAAQG,GAEtD,OAAOd,EAAkBO,EAASpO,EAAQqO,EAAS5N,EAAQ6N,EAAQI,EAAYF,EAAQG,SAY3F,OAFAxE,GAAa/C,iBAAkBnL,GAC/BkO,GAAa/C,iBAAkBmB,GACxBtO,IAjpBT,2BAspBC,SAAeV,EAAKqV,GAKnB,OAHAnG,GAAI7f,IAAK2Q,EAAIvM,IAAKuM,EAAItM,IAAK2hB,GAC3BnG,GAAIxL,aAAc,EAEXpE,KAAKgO,UACX,CACCwC,iBAAkB,SAAA9P,GAAG,OAAIkP,GAAIpF,cAAe9J,IAC5C+E,mBAAoB,SAAAhT,GAAG,OAAImd,GAAInK,mBAAoBhT,QA9pBvD,8BAoqBC,SAAkB0Q,GAEjB,OAAOnD,KAAKgO,UACX,CACCwC,iBAAkB,SAAA9P,GAAG,OAAIyC,EAAOqH,cAAe9J,IAC/C+E,mBAAoB,SAAAhT,GAAG,OAAIA,EAAIujB,iBAAkB7S,QAzqBrD,oCA+qBC,SAAwB2M,EAAeC,GAAyF,IAA1E5N,EAA0E,uDAAhE,GAAKC,EAA2D,uDAAjD,GAAK6T,EAA4C,uDAA7B,EAAGC,EAA0B,uDAAXzhB,IAE7Gqb,EAAcjhB,aAEpBihB,EAAcG,qBAIfL,GAAI7f,IAAK+f,EAAcjhB,YAAYsF,IAAK2b,EAAcjhB,YAAYuF,IAAK2b,GACvEH,GAAIxL,aAAc,EAElB,IAAM4F,EAAWhK,KAAKgK,SAChBhS,EAAMgS,EAASlX,WAAWhD,SAC1B8C,EAAQoX,EAASpX,MACjBujB,EAAWrG,EAAchd,WAAWhD,SACpCsmB,EAAatG,EAAcld,MAC3BwQ,EAAWkO,GAAajD,eACxBqB,EAAY4B,GAAajD,eAE3BgI,EAAcpU,GACdqU,EAAkBpU,GAClBqU,EAAc,KACdC,EAAkB,KAEjBpU,IAEJmU,EAAcpF,GACdqF,EAAkBpF,IAInB,IAAIqF,EAAkBhiB,IAClBiiB,EAA0B,KAC1BC,EAA+B,KA2JnC,OA1JAzF,GAAWvO,KAAMoN,GAAgBxF,SACjCsF,GAAK3G,OAAOvG,KAAMuO,IAClBlR,KAAKgO,UACJ,CAEC0G,oBAAqB,SAAAhU,GAEpB,OAAOkP,GAAI7E,cAAerK,IAI3B8P,iBAAkB,SAAE9P,EAAKd,EAAQgX,GAEhC,OAAKA,EAAQH,GAAmBG,EAAQV,IAIlCtW,IAEJiQ,GAAK1b,IAAIwO,KAAMjC,EAAIvM,KACnB0b,GAAKzb,IAAIuO,KAAMjC,EAAItM,KACnByb,GAAKzL,aAAc,IAIb,IAQTuQ,gBAAiB,SAAE5e,EAAQC,GAE1B,GAAK8Z,EAAcS,WAIlB,OAAOT,EAAcS,WAAWvC,UAAW,CAC1C0G,oBAAqB,SAAAhU,GAEpB,OAAOmP,GAAK9E,cAAerK,IAI5B8P,iBAAkB,SAAE9P,EAAKd,EAAQgX,GAEhC,OAAOA,EAAQH,GAAmBG,EAAQV,GAI3CvB,gBAAiB,SAAEkC,EAAaC,GAE/B,IAAM,IAAIhQ,EAAmB,EAAd+P,EAAiB1V,EAAoC,GAA7B0V,EAAcC,GAAkBhQ,EAAK3F,EAAI2F,GAAM,EAAI,CAEzFyC,EAAamG,EAAW5I,EAAIsP,EAAYD,GACxCzG,EAAU1e,EAAEoC,aAAc2c,GAC1BL,EAAUze,EAAEmC,aAAc2c,GAC1BL,EAAUxe,EAAEkC,aAAc2c,GAC1BL,EAAUtL,aAAc,EAExB,IAAM,IAAI1P,EAAa,EAATqB,EAAYoK,EAAyB,GAAnBpK,EAASC,GAAatB,EAAIyL,EAAGzL,GAAK,EAAI,CAErE6U,EAAanG,EAAU1O,EAAG9B,EAAOoF,GACjCoL,EAASgB,aAAc,EAEvB,IAAMzP,EAAOyO,EAASgF,mBAAoBsH,EAAW2G,EAAaE,GAkBlE,GAjBK5hB,EAAO8hB,IAEXH,EAAgB3T,KAAM0T,GAEjBG,GAEJA,EAAgB7T,KAAM4T,GAIvBE,EAAkB9hB,EAClB+hB,EAA0BhiB,EAAI,EAC9BiiB,EAA+B7P,EAAK,GAKhCnS,EAAOshB,EAEX,OAAO,OAeZ,IADA,IACUnP,EAAK,EAAG3F,EADDiV,EAAaA,EAAWpgB,MAAQmgB,EAASngB,MACzB8Q,EAAK3F,EAAI2F,GAAM,EAAI,CAEnDyC,EAAamG,EAAW5I,EAAIsP,EAAYD,GACxCzG,EAAU1e,EAAEoC,aAAc2c,GAC1BL,EAAUze,EAAEmC,aAAc2c,GAC1BL,EAAUxe,EAAEkC,aAAc2c,GAC1BL,EAAUtL,aAAc,EAExB,IAAM,IAAI1P,EAAa,EAATqB,EAAYoK,EAAyB,GAAnBpK,EAASC,GAAatB,EAAIyL,EAAGzL,GAAK,EAAI,CAErE6U,EAAanG,EAAU1O,EAAG9B,EAAOoF,GACjCoL,EAASgB,aAAc,EAEvB,IAAMzP,EAAOyO,EAASgF,mBAAoBsH,EAAW2G,EAAaE,GAkBlE,GAjBK5hB,EAAO8hB,IAEXH,EAAgB3T,KAAM0T,GAEjBG,GAEJA,EAAgB7T,KAAM4T,GAIvBE,EAAkB9hB,EAClB+hB,EAA0BhiB,EAAI,EAC9BiiB,EAA+B7P,EAAK,GAKhCnS,EAAOshB,EAEX,OAAO,OAgBd3E,GAAa/C,iBAAkBnL,GAC/BkO,GAAa/C,iBAAkBmB,GAE1B+G,IAAoBhiB,IAAkB,MAEpC0N,EAAQ1Q,MACV0Q,EAAQ1Q,MAAMkR,KAAM2T,GADFnU,EAAQ1Q,MAAQ6kB,EAAgBtkB,QAEvDmQ,EAAQtQ,SAAW4kB,EACnBtU,EAAQ7P,UAAYokB,EAEftU,IAEGA,EAAQ3Q,MACV2Q,EAAQ3Q,MAAMkR,KAAM6T,GADFpU,EAAQ3Q,MAAQ+kB,EAAgBxkB,QAEvDoQ,EAAQ3Q,MAAM2B,aAAc8d,IAC5BoF,EAAgBljB,aAAc8d,IAC9B9O,EAAQvQ,SAAWykB,EAAgBS,IAAK3U,EAAQ3Q,OAAQqI,SACxDsI,EAAQ9P,UAAYqkB,GAIdxU,KA73BT,iCAi4BC,SAAqB1Q,GAAiE,IAA1DyC,EAA0D,uDAAjD,GAAK+hB,EAA4C,uDAA7B,EAAGC,EAA0B,uDAAXzhB,IAMpEuiB,EAAiBf,EAAeA,EAChCgB,EAAiBf,EAAeA,EAClC5Q,EAAoB7Q,IACpBiiB,EAA0B,KA8C9B,GA7CA1W,KAAKgO,UAEJ,CAEC0G,oBAAqB,SAAAhU,GAGpB,OADAwO,GAAKvM,KAAMlR,GAAQqZ,MAAOpK,EAAIvM,IAAKuM,EAAItM,KAChC8a,GAAKxM,kBAAmBjR,IAIhC+e,iBAAkB,SAAE9P,EAAKd,EAAQgX,GAEhC,OAAOA,EAAQtR,GAAqBsR,EAAQK,GAI7CxR,mBAAoB,SAAEhT,EAAKykB,GAE1BzkB,EAAI8P,oBAAqB9Q,EAAOyd,IAChC,IAAM7J,EAAS5T,EAAMiR,kBAAmBwM,IASxC,OARK7J,EAASC,IAEbrD,GAAMU,KAAMuM,IACZ5J,EAAoBD,EACpBqR,EAA0BQ,GAItB7R,EAAS2R,KAgBZ1R,IAAsB7Q,IAAW,OAAO,KAE7C,IAAMgiB,EAAkB7iB,KAAK4R,KAAMF,GAOnC,OALOpR,EAAOzC,MACTyC,EAAOzC,MAAMkR,KAAMV,IADF/N,EAAOzC,MAAQwQ,GAAMjQ,QAE3CkC,EAAOrC,SAAW4kB,EAClBviB,EAAO5B,UAAYokB,EAEZxiB,IAj8BT,4BAq8BC,SAAgBA,GAYf,OAVAA,EAAOijB,YAEOnX,KAAK4R,OACbwF,SAAS,SAAA7X,GAEdxL,EAAY,EAAG,IAAI8E,aAAc0G,GAAU8R,IAC3Cnd,EAAOmjB,MAAOhG,OAIRnd,KAj9BT,wBAEC,SAAkBojB,GAAoB,IAAfpc,EAAe,uDAAL,GAEhC,GAAKA,EAAQsW,iBAIZ,OAFAzW,QAAQC,KAAM,wGAEPuW,EAAQgG,UACdC,UAAW,GACX,CACCC,kBAAiCC,IAAnBF,UAAW,IAA2BA,UAAW,KAMlEtc,GAAU,QACTuc,cAAc,GACXvc,GAGJ,IAAM8O,EAAWsN,EAAItN,SACf2N,EAAWL,EAAI1F,OACfgG,EAAiB5N,EAAS6N,WAkBhC,OAhBK3c,EAAQuc,aAEH,CACRvZ,MAAOyZ,EAAS/e,KAAK,SAAAkG,GAAI,OAAIA,EAAKgZ,WAClCllB,MAAOglB,EAAe3jB,MAAM6jB,SAKpB,CACR5Z,MAAOyZ,EACP/kB,MAAOglB,EAAe3jB,SArC1B,yBA8CC,SAAoBuJ,EAAMwM,GAAyB,IAAf9O,EAAe,uDAAL,GAE7C,GAAwB,mBAAZA,EAIX,OAFAH,QAAQC,KAAM,0GAEPuW,EAAQwG,YACdP,UAAW,GACXA,UAAW,GACX,CACC1a,cAA6B4a,IAAnBF,UAAW,IAA2BA,UAAW,KAM9Dtc,GAAU,QACT4B,UAAU,GACP5B,GAGJ,IAAQtI,EAAiB4K,EAAjB5K,MAAOsL,EAAUV,EAAVU,MACToZ,EAAM,IAAI/F,EAASvH,GAAb,kBAA4B9O,GAA5B,cAAuC4V,IAAmB,KAGtE,GAFAwG,EAAI1F,OAAS1T,EAERhD,EAAQ4B,SAAW,CAEvB,IAAM8a,EAAiB5N,EAAS6N,WAChC,GAAwB,OAAnBD,EAA0B,CAE9B,IAAMI,EAAW,IAAIjb,EAAAA,gBAAiBS,EAAK5K,MAAO,GAAG,GACrDoX,EAASlN,SAAUkb,QAERJ,EAAe3jB,QAAUrB,IAEpCglB,EAAe3jB,MAAMlE,IAAK6C,GAC1BglB,EAAexT,aAAc,GAM/B,OAAOkT,MAxFT,KAw9BMW,GAAkB1G,GAAQ/Q,UAAUmM,QAC1C4E,GAAQ/Q,UAAUmM,QAAU,WAAqB,2BAAP5I,EAAO,yBAAPA,EAAO,gBAEhD,GAAKA,EAAM,GAAImU,OAAS,CAEvBnd,QAAQC,KAAM,4GACd,IACCmd,EACGpU,EAFJ,GACO5Q,EACH4Q,EAFJ,GACkBjT,EACdiT,EAFJ,GACuB6I,EACnB7I,EAFJ,GAIMqU,EAAUH,GAAgBI,KAAMrY,KAAMlP,EAAKqnB,EAAKG,UAYtD,OAXAF,EAAQhB,SAAS,SAAAnkB,IAEhBA,EAAMD,EAAyBC,EAAKklB,EAAMhlB,KAGzCyZ,EAAW7Z,KAAME,MAMZ2Z,EAIP,OAAOqL,GAAgBM,MAAOvY,KAAM+D,IAMtC,IAAMyU,GAAuBjH,GAAQ/Q,UAAU6M,aAC/CkE,GAAQ/Q,UAAU6M,aAAe,WAAqB,2BAAPtJ,EAAO,yBAAPA,EAAO,gBAErD,GAAKA,EAAM,GAAImU,OAAS,CAEvBnd,QAAQC,KAAM,iHACd,IACCmd,EACGpU,EAFJ,GACO5Q,EACH4Q,EAFJ,GACkBjT,EACdiT,EAFJ,GAIA,OAAO/Q,EAAyBwlB,GAAqBH,KAAMrY,KAAMlP,EAAKqnB,EAAKG,UAAYH,EAAMhlB,GAI7F,OAAOqlB,GAAqBD,MAAOvY,KAAM+D,IAM3C,IAAM0U,GAA8BlH,GAAQ/Q,UAAU+B,oBACtDgP,GAAQ/Q,UAAU+B,oBAAsB,WAAqB,2BAAPwB,EAAO,yBAAPA,EAAO,gBAG5D,GAAKA,EAAM,GAAImU,OAAS,CAEvBnd,QAAQC,KAAM,wHAEd+I,EAAK2U,UAEL,IAAMxkB,EAAS6P,EAAM,GACf3C,EAAS,GAWf,OAVA2C,EAAM,GAAM3C,EAEZqX,GAA4BF,MAAOvY,KAAM+D,GAEpC7P,GAEJA,EAAOyO,KAAMvB,EAAO3P,OAId2P,EAAOvP,SAId,OAAO4mB,GAA4BF,MAAOvY,KAAM+D,IAMlD,IAAM4U,GAAiCpH,GAAQ/Q,UAAUoY,uBACzDrH,GAAQ/Q,UAAUoY,uBAAyB,WAAqB,2BAAP7U,EAAO,yBAAPA,EAAO,gBAE/D,IAAM5B,EAAU4B,EAAM,GAChB3B,EAAU2B,EAAM,GACtB,GAAK5B,GAAWA,EAAQ0W,WAAazW,GAAWA,EAAQyW,UAAY,CAEnE9d,QAAQC,KAAM,2HAEd,IAAM8d,EAAU,GACVC,EAAU,GACVhJ,EAAgBhM,EAAM,GAkB5B,OAjBAA,EAAM,GAAM+U,EACZ/U,EAAM,GAAMgV,EAEZJ,GAA+BJ,MAAOvY,KAAM+D,GAEvC5B,GAEJA,EAAQQ,KAAMmW,EAAQrnB,OAIlB2Q,GAEJA,EAAQO,KAAMoW,EAAQtnB,OAAQ2B,aAAc2c,GAItC+I,EAAQjnB,SAIf,OAAO8mB,GAA+BJ,MAAOvY,KAAM+D,IAMrD,IAAMiV,GAAgBzH,GAAQ/Q,UAAUyY,MACxC1H,GAAQ/Q,UAAUyY,MAAQ,WAAqB,2BAAPlV,EAAO,yBAAPA,EAAO,gBAE9C,IAAM+N,EAAc/N,EAAM,GACpBmV,EAAqBnV,EAAM,GACjC,GAAKmV,IAAwBA,aAA8B5a,KAAO5F,MAAMqZ,QAASmH,IAAyB,CAEzGne,QAAQC,KAAM,wFAEd,IAAMme,EAAiB,IAAI7a,IAC3B4a,EAAmB9B,SAAS,SAAAjN,GAAC,OAAIgP,EAAezpB,IAAKya,MAChD2H,GAEJA,EAAYsF,SAAS,SAAAjN,GAAC,OAAIgP,EAAezpB,IAAKya,MAI/C6O,GAAcX,KAAMrY,KAAMmZ,QAI1BH,GAAcT,MAAOvY,KAAM+D,IAM7B,CACC,qBACA,YACA,gBACA,oBACCqT,SAAS,SAAAgC,GAEV,IAAMC,EAAe9H,GAAQ/Q,UAAW4Y,GACxC7H,GAAQ/Q,UAAW4Y,GAAS,WAAqB,2BAAPrV,EAAO,yBAAPA,EAAO,gBAShD,OAPmB,OAAdA,EAAM,IAAgBA,EAAM,GAAImU,UAEpCnU,EAAKuV,QACLve,QAAQC,KAAR,+CAAuDoe,EAAvD,yEAIMC,EAAad,MAAOvY,KAAM+D,OC5pCnC,IAAMjT,GAAsB,IAAIyoB,EAAAA,IAC1BC,GAAmC,IAAIrQ,EAAAA,QACvCsQ,GAAsBC,EAAAA,KAAAA,UAAAA,QAErB,SAASC,GAAoBxmB,EAAWyZ,GAE9C,GAAK5M,KAAKgK,SAASuG,WAAa,CAE/B,QAAuBmH,IAAlB1X,KAAKsY,SAAyB,OAEnCkB,GAAiB7W,KAAM3C,KAAK3M,aAAckX,SAC1CzZ,GAAI6R,KAAMxP,EAAUrC,KAAMsC,aAAcomB,IAExC,IAAMlC,EAAMtX,KAAKgK,SAASuG,WAC1B,IAAgC,IAA3Bpd,EAAUymB,aAAwB,CAEtC,IAAM3mB,EAAMD,EAAyBskB,EAAIjK,aAAcvc,GAAKkP,KAAKsY,UAAYtY,KAAM7M,GAC9EF,GAEJ2Z,EAAW7Z,KAAME,QAOlB,IADA,IAAM4mB,EAAOvC,EAAI3K,QAAS7b,GAAKkP,KAAKsY,UAC1B5jB,EAAI,EAAGyL,EAAI0Z,EAAK/f,OAAQpF,EAAIyL,EAAGzL,IAAO,CAE/C,IAAMzB,EAAMD,EAAyB6mB,EAAMnlB,GAAKsL,KAAM7M,GACjDF,GAEJ2Z,EAAW7Z,KAAME,SAUpBwmB,GAAoBpB,KAAMrY,KAAM7M,EAAWyZ,GAMtC,SAASkN,GAAmB5e,GAGlC,OADA8E,KAAKuQ,WAAa,IAAIgB,GAASvR,KAAM9E,GAC9B8E,KAAKuQ,WAIN,SAASwJ,KAEf/Z,KAAKuQ,WAAa,KCzDnB,SAASyJ,GAAO7B,EAAMjd,GACpB9L,EAAAA,WAAgB,WACd,GAAI+oB,EAAK3oB,QAAS,CAChB2oB,EAAK3oB,QAAQmd,QAAUgN,GACvB,IAAM3P,EAAWmO,EAAK3oB,QAAQwa,SAI9B,OAHAA,EAAS8P,kBAAoBA,GAC7B9P,EAAS+P,kBAAoBA,GAC7B/P,EAAS8P,kBAAkB5e,GACpB,WACD8O,EAASuG,YACXvG,EAAS+P,wBAId,CAAC5B,EAAMjd,M,yICXN+e,EAAgB,WACpB,IAAMC,EAAU,IAAIC,EAAAA,QACd/f,EAAS,IAAI/J,EAAAA,QACb+pB,EAAW,IAAI/pB,EAAAA,QACfgqB,EAAU,IAAIhqB,EAAAA,QACdiqB,EAAa,IAAIjqB,EAAAA,QACjBkqB,EAAc,IAAIlqB,EAAAA,QAClBmqB,EAAe,IAAInqB,EAAAA,QACnBoqB,EAAc,IAAIpqB,EAAAA,QAClBqqB,EAAgB,IAAIrqB,EAAAA,QACpBsqB,EAAiB,IAAItqB,EAAAA,QACrBuqB,EAAkB,IAAIvqB,EAAAA,QACtBwqB,EAAiB,IAAIxqB,EAAAA,QACrByqB,EAAW,IAAIzqB,EAAAA,QACf0qB,EAAW,IAAI1qB,EAAAA,QACf2qB,EAAW,IAAI3qB,EAAAA,QAEf4pB,EAjBoB,WAkBxB,WAAYgB,EAAQC,EAAOC,IAAM,eAC/Bnb,KAAKib,OAASA,EACdjb,KAAKkb,MAAQA,EACblb,KAAKob,WAAa,IAAI/qB,EAAAA,QACtB2P,KAAKqb,SAAW,IAAIhrB,EAAAA,QACpB2P,KAAKsb,WAAa,GAClBtb,KAAKmb,KAAOA,GAAQI,OAAOC,UAxBL,qCA2BxB,SAAOJ,EAAYC,GAMjB,OALArb,KAAKob,WAAaA,GAAcpb,KAAKob,WACrCpb,KAAKqb,SAAWA,GAAYrb,KAAKqb,SACjCrb,KAAKsb,WAAa,GAClBtb,KAAKyb,cAAczb,KAAKob,WAAYpb,KAAKqb,UACzCrb,KAAK0b,qBAAqBxB,EAASla,KAAKkb,OACjClb,KAAKsb,aAjCU,2BAoCxB,SAAcF,EAAYC,GAexB,GAdAD,EAAaA,GAAcpb,KAAKob,WAChCC,EAAWA,GAAYrb,KAAKqb,SAExBD,EAAWprB,IAAMqrB,EAASrrB,IAC5BqrB,EAASrrB,GAAKurB,OAAOI,SAGnBP,EAAWnrB,IAAMorB,EAASprB,IAC5BorB,EAASprB,GAAKsrB,OAAOI,SAGvB3b,KAAKib,OAAOW,yBACZ5b,KAAKib,OAAOY,oBAER7b,KAAKib,OAAOa,oBACd1B,EAASzX,KAAKyY,GACdhB,EAASpqB,EAAI4D,KAAKO,IAAIinB,EAAWprB,EAAGqrB,EAASrrB,GAC7CoqB,EAASnqB,EAAI2D,KAAKQ,IAAIgnB,EAAWnrB,EAAGorB,EAASprB,GAC7CorB,EAASrrB,EAAI4D,KAAKQ,IAAIgnB,EAAWprB,EAAGqrB,EAASrrB,GAC7CqrB,EAASprB,EAAI2D,KAAKO,IAAIinB,EAAWnrB,EAAGorB,EAASprB,GAC7CoqB,EAAQ0B,sBAAsB/b,KAAKib,OAAO5nB,aAC1CinB,EAAW3X,KAAKyX,GAChBG,EAAYxqB,IAAIsrB,EAASrrB,EAAGoqB,EAASnqB,EAAG,GACxCuqB,EAAa7X,KAAK0Y,GAClBZ,EAAY1qB,IAAIqqB,EAASpqB,EAAGqrB,EAASprB,EAAG,GACxCqqB,EAAW0B,UAAUhc,KAAKib,QAC1BV,EAAYyB,UAAUhc,KAAKib,QAC3BT,EAAawB,UAAUhc,KAAKib,QAC5BR,EAAYuB,UAAUhc,KAAKib,QAC3BH,EAASnY,KAAK2X,GAAYvD,IAAIsD,GAC9BU,EAASpY,KAAK4X,GAAaxD,IAAIsD,GAC/BW,EAASrY,KAAK6X,GAAczD,IAAIsD,GAChCS,EAASmB,YACTlB,EAASkB,YACTjB,EAASiB,YACTnB,EAASoB,eAAelc,KAAKmb,MAC7BJ,EAASmB,eAAelc,KAAKmb,MAC7BH,EAASkB,eAAelc,KAAKmb,MAC7BL,EAASprB,IAAI2qB,GACbU,EAASrrB,IAAI2qB,GACbW,EAAStrB,IAAI2qB,IACT8B,EAASjC,EAAQiC,QACd,GAAGC,sBAAsB/B,EAASC,EAAYC,GACrD4B,EAAO,GAAGC,sBAAsB/B,EAASE,EAAaC,GACtD2B,EAAO,GAAGC,sBAAsB5B,EAAcC,EAAaJ,GAC3D8B,EAAO,GAAGC,sBAAsB3B,EAAaH,EAAYD,GACzD8B,EAAO,GAAGC,sBAAsB7B,EAAaC,EAAcC,GAC3D0B,EAAO,GAAGC,sBAAsBpB,EAAUD,EAAUD,GACpDqB,EAAO,GAAG/pB,OAAO8pB,gBAAgB,QAC5B,GAAIlc,KAAKib,OAAOoB,qBAAsB,CAC3C,IAoBIF,EApBErkB,EAAOlE,KAAKO,IAAIinB,EAAWprB,EAAGqrB,EAASrrB,GACvCssB,EAAM1oB,KAAKQ,IAAIgnB,EAAWnrB,EAAGorB,EAASprB,GACtC8H,EAAQnE,KAAKQ,IAAIgnB,EAAWprB,EAAGqrB,EAASrrB,GACxCusB,EAAO3oB,KAAKO,IAAIinB,EAAWnrB,EAAGorB,EAASprB,GAC7CqqB,EAAWvqB,IAAI+H,EAAMwkB,GAAM,GAC3B/B,EAAYxqB,IAAIgI,EAAOukB,GAAM,GAC7B9B,EAAazqB,IAAIgI,EAAOwkB,GAAO,GAC/B9B,EAAY1qB,IAAI+H,EAAMykB,GAAO,GAC7B7B,EAAc3qB,IAAI+H,EAAMwkB,EAAK,GAC7B3B,EAAe5qB,IAAIgI,EAAOukB,EAAK,GAC/B1B,EAAgB7qB,IAAIgI,EAAOwkB,EAAM,GACjC1B,EAAe9qB,IAAI+H,EAAMykB,EAAM,GAC/BjC,EAAW0B,UAAUhc,KAAKib,QAC1BV,EAAYyB,UAAUhc,KAAKib,QAC3BT,EAAawB,UAAUhc,KAAKib,QAC5BR,EAAYuB,UAAUhc,KAAKib,QAC3BP,EAAcsB,UAAUhc,KAAKib,QAC7BN,EAAeqB,UAAUhc,KAAKib,QAC9BL,EAAgBoB,UAAUhc,KAAKib,QAC/BJ,EAAemB,UAAUhc,KAAKib,SAC1BkB,EAASjC,EAAQiC,QACd,GAAGC,sBAAsB9B,EAAYI,EAAeC,GAC3DwB,EAAO,GAAGC,sBAAsB7B,EAAaI,EAAgBC,GAC7DuB,EAAO,GAAGC,sBAAsBxB,EAAiBC,EAAgBJ,GACjE0B,EAAO,GAAGC,sBAAsBvB,EAAgBH,EAAeJ,GAC/D6B,EAAO,GAAGC,sBAAsB7B,EAAaC,EAAcC,GAC3D0B,EAAO,GAAGC,sBAAsBxB,EAAiBD,EAAgBD,GACjEyB,EAAO,GAAG/pB,OAAO8pB,gBAAgB,QAEjCnhB,QAAQyhB,MAAM,kDApHM,kCAwHxB,SAAqBtC,EAAShnB,GAa5B,IAZIA,EAAOglB,QAAUhlB,EAAOupB,QAAUvpB,EAAOwpB,gBACnBhF,IAApBxkB,EAAOolB,WAC8B,OAAnCplB,EAAO8W,SAAS2S,gBAAyBzpB,EAAO8W,SAAS4S,wBAC7DxiB,EAAOuI,KAAKzP,EAAO8W,SAAS2S,eAAeviB,QAC3CA,EAAOhH,aAAaF,EAAOG,aAEvB6mB,EAAQvW,cAAcvJ,IACxB4F,KAAKsb,WAAWvoB,KAAKG,IAKvBA,EAAO2pB,SAAS/iB,OAAS,EAC3B,IAAK,IAAI9J,EAAI,EAAGA,EAAIkD,EAAO2pB,SAAS/iB,OAAQ9J,IAC1CgQ,KAAK0b,qBAAqBxB,EAAShnB,EAAO2pB,SAAS7sB,QAvIjC,KA8I1B,OAAOiqB,EA9Ia,G,mGCChB6C,EAAuB1tB,EAAAA,cAAoB,IACjD,SAAS2tB,EAAT,GASG,IARDrc,EAQC,EARDA,IACAsc,EAOC,EAPDA,SACAH,EAMC,EANDA,SACAI,EAKC,EALDA,SAKC,IAJDC,OAAAA,OAIC,MAJQ,oBAIR,MAHDC,gBAAAA,OAGC,MAHiB,0BAGjB,MAFDC,OAAQC,OAEP,MAFsB,SAAAC,GAAI,OAAIA,GAE9B,EADEpuB,GACF,YACD,GAQIquB,EAAAA,EAAAA,KAPFC,EADF,EACEA,UACAvC,EAFF,EAEEA,OACA9nB,EAHF,EAGEA,UACAsqB,EAJF,EAIEA,GACAC,EALF,EAKEA,SACAC,EANF,EAMEA,KACAC,EAPF,EAOEA,IAEF,EAAyBxuB,EAAAA,UAAe,GAAxC,eAAOyuB,EAAP,KAAgBC,EAAhB,KACA,EAA2B1uB,EAAAA,YAAiB,SAAC2uB,EAAD,GAGtC,IAFJ7qB,EAEI,EAFJA,OACAomB,EACI,EADJA,MAEA,YAAe5B,IAAXxkB,EAA6B,GAAYwF,MAAMqZ,QAAQ7e,GAAgBA,EAAiBomB,EAA2DyE,EAAMC,SAAS9qB,GAAgB6qB,EAAMX,QAAO,SAAAa,GAAC,OAAIA,IAAM/qB,KAAoB,CAACA,GAAR,eAAmB6qB,IAApIA,EAAM,KAAO7qB,EAAS,GAAK,CAACA,KACrI,IALH,eAAOgrB,EAAP,KAAeC,EAAf,KAMA/uB,EAAAA,WAAgB,WAAwB,MAAZ6tB,GAA4BA,EAASiB,KAAU,CAACA,IAC5E,IAAME,EAAUhvB,EAAAA,aAAkB,SAAAivB,GAChCA,EAAEC,kBACFH,EAAS,CACPjrB,OAAQmqB,EAAa,CAACgB,EAAEnrB,SAAS,GACjComB,MAAO0D,GAAYqB,EAAEE,aAEtB,IACGC,EAAkBpvB,EAAAA,aAAkB,SAAAivB,GAAC,OAAKR,GAAWM,EAAS,MAAK,CAACN,IACpE1uB,EAAMC,EAAAA,OAAa,MAiHzB,OAhHAA,EAAAA,WAAgB,WACd,GAAKsR,GAAQsc,EAAb,CACA,IAAMyB,EAAS,IAAIxE,EAAagB,EAAQ9rB,EAAIK,SACtCkvB,EAAUC,SAASC,cAAc,OACvCF,EAAQG,MAAMC,cAAgB,OAC9BJ,EAAQG,MAAM3B,OAASA,EACvBwB,EAAQG,MAAM1B,gBAAkBA,EAChCuB,EAAQG,MAAM/uB,SAAW,QACzB,IAAMsrB,EAAa,IAAItsB,EAAAA,QACjBiwB,EAAe,IAAIjwB,EAAAA,QACnBkwB,EAAmB,IAAIlwB,EAAAA,QACvBmwB,EAAsBrB,IAAMsB,OAAOC,QACnCC,EAAiC,MAAZ1B,OAAmB,EAASA,EAASyB,QAC5DE,GAAS,EA8DTC,EAAW,GA+Bf,OAVAX,SAASY,iBAAiB,cAAeC,EAAa,CACpDC,SAAS,IAEXd,SAASY,iBAAiB,cAAeG,EAAa,CACpDD,SAAS,EACTE,SAAS,IAEXhB,SAASY,iBAAiB,YAAaK,EAAW,CAChDH,SAAS,IAEJ,WACLd,SAASkB,oBAAoB,cAAeL,GAC5Cb,SAASkB,oBAAoB,cAAeH,GAC5Cf,SAASkB,oBAAoB,YAAaD,IA9F5C,SAASE,EAAWC,EAAOC,GACzB,IACEC,EAEEF,EAFFE,QACAC,EACEH,EADFG,QAGAC,EAEExC,EAFFwC,MACAC,EACEzC,EADFyC,OAEFJ,EAAIjwB,IAAIkwB,EAAUE,EAAQ,EAAI,GAAKD,EAAUE,EAAU,EAAI,GA4C7D,SAASZ,EAAYO,GACfA,EAAMxB,YA1CZ,SAAuBwB,GACrB,IAAIM,EAEA3C,IAAUA,EAASyB,SAAU,GACjC3B,EAAU,CACR2B,SAAS,IAEXE,GAAS,EACgD,OAAxDgB,EAAwB5C,EAAG6C,WAAWC,gBAAkCF,EAAsBG,YAAY9B,GAC3GA,EAAQG,MAAM/mB,KAAd,UAAwBioB,EAAMU,QAA9B,MACA/B,EAAQG,MAAMvC,IAAd,UAAuByD,EAAMW,QAA7B,MACAhC,EAAQG,MAAMsB,MAAQ,MACtBzB,EAAQG,MAAMuB,OAAS,MACvBhF,EAAWprB,EAAI+vB,EAAMU,QACrBrF,EAAWnrB,EAAI8vB,EAAMW,QA6BnBC,CAAcZ,GACdD,EAAWC,EAAOtB,EAAOrD,aAM7B,SAASsE,EAAYK,GACnB,GAAIV,EAAQ,EAlCd,SAAsBU,GACpBf,EAAiBhvB,EAAI4D,KAAKQ,IAAIgnB,EAAWprB,EAAG+vB,EAAMU,SAClDzB,EAAiB/uB,EAAI2D,KAAKQ,IAAIgnB,EAAWnrB,EAAG8vB,EAAMW,SAClD3B,EAAa/uB,EAAI4D,KAAKO,IAAIinB,EAAWprB,EAAG+vB,EAAMU,SAC9C1B,EAAa9uB,EAAI2D,KAAKO,IAAIinB,EAAWnrB,EAAG8vB,EAAMW,SAC9ChC,EAAQG,MAAM/mB,KAAd,UAAwBinB,EAAa/uB,EAArC,MACA0uB,EAAQG,MAAMvC,IAAd,UAAuByC,EAAa9uB,EAApC,MACAyuB,EAAQG,MAAMsB,MAAd,UAAyBnB,EAAiBhvB,EAAI+uB,EAAa/uB,EAA3D,MACA0uB,EAAQG,MAAMuB,OAAd,UAA0BpB,EAAiB/uB,EAAI8uB,EAAa9uB,EAA5D,MA2BE2wB,CAAab,GACbD,EAAWC,EAAOtB,EAAOpD,UACzB,IAAMwF,EAAcpC,EAAOqC,SAAS9mB,MAAK,SAAAikB,GAAC,OAAIA,EAAE8C,QAAM3D,QAAO,SAAAa,GAAC,OAAIA,EAAE/F,WAE/D8I,EAAAA,EAAAA,GAAQH,EAAavB,KACxBA,EAAWuB,EACX1C,EAAS,CACPjrB,OAAQmqB,EAAawD,OAM7B,SAASjB,EAAUG,GACbV,GAtCN,WAEI,IAAI4B,EADF5B,IAGE3B,IAAUA,EAASyB,QAAUC,GACjC5B,EAAU,CACR2B,QAASF,IAEXI,GAAS,EAC0C,OAAlD4B,EAAwBvC,EAAQ6B,gBAAkCU,EAAsBC,YAAYxC,IA6B3FyC,MAkBb,CAACxD,EAAMxqB,EAAW8nB,EAAQyC,EAAUD,IACnBruB,EAAAA,cAAoB,SAASe,EAAAA,EAAAA,GAAS,CACxDhB,IAAKA,EACLivB,QAASA,EACTgD,cAAe,kBAAMtD,GAAM,IAC3BuD,aAAc,kBAAMvD,GAAM,IAC1BU,gBAAiBA,GAChBtvB,GAAqBE,EAAAA,cAAoB0tB,EAAQwE,SAAU,CAC5Dzd,MAAOqa,GACNrB,M,mEClKL,SAAS0E,EAAU1D,GAA2D,IAAlDuD,EAAkD,uDAAlC,UAAWC,EAAuB,uDAAR,OACpEjyB,EAAAA,WAAgB,WACd,GAAIyuB,EAEF,OADAc,SAAS6C,KAAK3C,MAAM4C,OAASL,EACtB,WAAYzC,SAAS6C,KAAK3C,MAAM4C,OAASJ,KAEjD,CAACxD","sources":["../node_modules/@react-three/drei/core/BBAnchor.js","../node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","../node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js","../node_modules/three-mesh-bvh/src/core/Constants.js","../node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","../node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","../node_modules/three-mesh-bvh/src/core/buildFunctions.js","../node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","../node_modules/three-mesh-bvh/src/math/MathUtilities.js","../node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","../node_modules/three-mesh-bvh/src/math/OrientedBox.js","../node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","../node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","../node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js","../node_modules/three-mesh-bvh/src/core/castFunctions.js","../node_modules/three-mesh-bvh/src/core/MeshBVH.js","../node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js","../node_modules/@react-three/drei/core/useBVH.js","../node_modules/three-stdlib/interactive/SelectionBox.js","../node_modules/@react-three/drei/web/Select.js","../node_modules/@react-three/drei/web/useCursor.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useFrame } from '@react-three/fiber';\n\nconst boundingBox = new THREE.Box3();\nconst boundingBoxSize = new THREE.Vector3();\nconst BBAnchor = ({\n  anchor,\n  ...props\n}) => {\n  const ref = React.useRef(null);\n  const parentRef = React.useRef(null); // Reattach group created by this component to the parent's parent,\n  // so it becomes a sibling of its initial parent.\n  // We do that so the children have no impact on a bounding box of a parent.\n\n  React.useEffect(() => {\n    var _ref$current, _ref$current$parent;\n\n    if ((_ref$current = ref.current) != null && (_ref$current$parent = _ref$current.parent) != null && _ref$current$parent.parent) {\n      parentRef.current = ref.current.parent;\n      ref.current.parent.parent.add(ref.current);\n    }\n  }, []);\n  useFrame(() => {\n    if (parentRef.current) {\n      boundingBox.setFromObject(parentRef.current);\n      boundingBox.getSize(boundingBoxSize);\n      ref.current.position.set(parentRef.current.position.x + boundingBoxSize.x * anchor[0] / 2, parentRef.current.position.y + boundingBoxSize.y * anchor[1] / 2, parentRef.current.position.z + boundingBoxSize.z * anchor[2] / 2);\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props));\n};\n\nexport { BBAnchor };\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\r\n\r\n// Ripped and modified From THREE.js Mesh raycast\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\r\nconst vA = /* @__PURE__ */ new Vector3();\r\nconst vB = /* @__PURE__ */ new Vector3();\r\nconst vC = /* @__PURE__ */ new Vector3();\r\n\r\nconst uvA = /* @__PURE__ */ new Vector2();\r\nconst uvB = /* @__PURE__ */ new Vector2();\r\nconst uvC = /* @__PURE__ */ new Vector2();\r\n\r\nconst intersectionPoint = /* @__PURE__ */ new Vector3();\r\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\r\n\r\n\tlet intersect;\r\n\tif ( side === BackSide ) {\r\n\r\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t} else {\r\n\r\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\r\n\r\n\t}\r\n\r\n\tif ( intersect === null ) return null;\r\n\r\n\tconst distance = ray.origin.distanceTo( point );\r\n\r\n\treturn {\r\n\r\n\t\tdistance: distance,\r\n\t\tpoint: point.clone(),\r\n\r\n\t};\r\n\r\n}\r\n\r\nfunction checkBufferGeometryIntersection( ray, position, uv, a, b, c, side ) {\r\n\r\n\tvA.fromBufferAttribute( position, a );\r\n\tvB.fromBufferAttribute( position, b );\r\n\tvC.fromBufferAttribute( position, c );\r\n\r\n\tconst intersection = checkIntersection( ray, vA, vB, vC, intersectionPoint, side );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tif ( uv ) {\r\n\r\n\t\t\tuvA.fromBufferAttribute( uv, a );\r\n\t\t\tuvB.fromBufferAttribute( uv, b );\r\n\t\t\tuvC.fromBufferAttribute( uv, c );\r\n\r\n\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst face = {\r\n\t\t\ta: a,\r\n\t\t\tb: b,\r\n\t\t\tc: c,\r\n\t\t\tnormal: new Vector3(),\r\n\t\t\tmaterialIndex: 0\r\n\t\t};\r\n\r\n\t\tTriangle.getNormal( vA, vB, vC, face.normal );\r\n\r\n\t\tintersection.face = face;\r\n\t\tintersection.faceIndex = a;\r\n\r\n\t}\r\n\r\n\treturn intersection;\r\n\r\n}\r\n\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\r\nfunction intersectTri( geo, side, ray, tri, intersections ) {\r\n\r\n\tconst triOffset = tri * 3;\r\n\tconst a = geo.index.getX( triOffset );\r\n\tconst b = geo.index.getX( triOffset + 1 );\r\n\tconst c = geo.index.getX( triOffset + 2 );\r\n\r\n\tconst intersection = checkBufferGeometryIntersection( ray, geo.attributes.position, geo.attributes.uv, a, b, c, side );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tintersection.faceIndex = tri;\r\n\t\tif ( intersections ) intersections.push( intersection );\r\n\t\treturn intersection;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n}\r\n\r\nexport { intersectTri };\r\n","import { intersectTri } from './ThreeRayIntersectUtilities.js';\n\nexport function intersectTris( geo, side, ray, offset, count, intersections ) {\n\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tintersectTri( geo, side, ray, i, intersections );\n\n\t}\n\n}\n\nexport function intersectClosestTri( geo, side, ray, offset, count ) {\n\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tconst intersection = intersectTri( geo, side, ray, i );\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n","// Split strategy constants\r\nexport const CENTER = 0;\r\nexport const AVERAGE = 1;\r\nexport const SAH = 2;\r\n\r\n// Traversal constants\r\nexport const NOT_INTERSECTED = 0;\r\nexport const INTERSECTED = 1;\r\nexport const CONTAINED = 2;\r\n\r\n// SAH cost constants\r\n// TODO: hone these costs more. The relative difference between them should be the\r\n// difference in measured time to perform a triangle intersection vs traversing\r\n// bounds.\r\nexport const TRIANGLE_INTERSECT_COST = 1.25;\r\nexport const TRAVERSAL_COST = 1;\r\n\r\n\r\n// Build constants\r\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\r\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\r\n\r\n// EPSILON for computing floating point error during build\r\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\r\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\r\n\r\n","export class MeshBVHNode {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// internal nodes have boundingData, left, right, and splitAxis\r\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\r\n\r\n\t}\r\n\r\n}\r\n","export function arrayToBox( nodeIndex32, array, target ) {\r\n\r\n\ttarget.min.x = array[ nodeIndex32 ];\r\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\r\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\r\n\r\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\r\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\r\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\nexport function getLongestEdgeIndex( bounds ) {\r\n\r\n\tlet splitDimIdx = - 1;\r\n\tlet splitDist = - Infinity;\r\n\r\n\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\r\n\t\tif ( dist > splitDist ) {\r\n\r\n\t\t\tsplitDist = dist;\r\n\t\t\tsplitDimIdx = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn splitDimIdx;\r\n\r\n}\r\n\r\n// copys bounds a into bounds b\r\nexport function copyBounds( source, target ) {\r\n\r\n\ttarget.set( source );\r\n\r\n}\r\n\r\n// sets bounds target to the union of bounds a and b\r\nexport function unionBounds( a, b, target ) {\r\n\r\n\tlet aVal, bVal;\r\n\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\tconst d3 = d + 3;\r\n\r\n\t\t// set the minimum values\r\n\t\taVal = a[ d ];\r\n\t\tbVal = b[ d ];\r\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\r\n\r\n\t\t// set the max values\r\n\t\taVal = a[ d3 ];\r\n\t\tbVal = b[ d3 ];\r\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// expands the given bounds by the provided triangle bounds\r\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\r\n\r\n\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\r\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\r\n\r\n\t\tconst tMin = tCenter - tHalf;\r\n\t\tconst tMax = tCenter + tHalf;\r\n\r\n\t\tif ( tMin < bounds[ d ] ) {\r\n\r\n\t\t\tbounds[ d ] = tMin;\r\n\r\n\t\t}\r\n\r\n\t\tif ( tMax > bounds[ d + 3 ] ) {\r\n\r\n\t\t\tbounds[ d + 3 ] = tMax;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// compute bounds surface area\r\nexport function computeSurfaceArea( bounds ) {\r\n\r\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\r\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\r\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\r\n\r\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\r\n\r\n}\r\n","import { BufferAttribute } from 'three';\r\nimport { MeshBVHNode } from './MeshBVHNode.js';\r\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\r\nimport {\r\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\r\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\r\n} from './Constants.js';\r\n\r\nfunction ensureIndex( geo, options ) {\r\n\r\n\tif ( ! geo.index ) {\r\n\r\n\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\t\tlet index;\r\n\t\tif ( vertexCount > 65535 ) {\r\n\r\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\r\n\r\n\t\t}\r\n\r\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\r\n\r\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\tindex[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\r\n// region in the geometry index that belongs to a different set of material groups requires\r\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\r\n// with triangle indices belongs to another group. For example, if the groups were like this:\r\n//\r\n// [-------------------------------------------------------------]\r\n// |__________________|\r\n//   g0 = [0, 20]  |______________________||_____________________|\r\n//                      g1 = [16, 40]           g2 = [41, 60]\r\n//\r\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\r\nfunction getRootIndexRanges( geo ) {\r\n\r\n\tif ( ! geo.groups || ! geo.groups.length ) {\r\n\r\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\r\n\r\n\t}\r\n\r\n\tconst ranges = [];\r\n\tconst rangeBoundaries = new Set();\r\n\tfor ( const group of geo.groups ) {\r\n\r\n\t\trangeBoundaries.add( group.start );\r\n\t\trangeBoundaries.add( group.start + group.count );\r\n\r\n\t}\r\n\r\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\r\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\r\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\r\n\r\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\r\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\r\n\r\n\t}\r\n\r\n\treturn ranges;\r\n\r\n}\r\n\r\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\r\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\r\n// These are computed together to avoid redundant accesses to bounds array.\r\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\r\n\r\n\tlet minx = Infinity;\r\n\tlet miny = Infinity;\r\n\tlet minz = Infinity;\r\n\tlet maxx = - Infinity;\r\n\tlet maxy = - Infinity;\r\n\tlet maxz = - Infinity;\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tconst includeCentroid = centroidTarget !== null;\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tconst hx = triangleBounds[ i + 1 ];\r\n\t\tconst lx = cx - hx;\r\n\t\tconst rx = cx + hx;\r\n\t\tif ( lx < minx ) minx = lx;\r\n\t\tif ( rx > maxx ) maxx = rx;\r\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\r\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tconst hy = triangleBounds[ i + 3 ];\r\n\t\tconst ly = cy - hy;\r\n\t\tconst ry = cy + hy;\r\n\t\tif ( ly < miny ) miny = ly;\r\n\t\tif ( ry > maxy ) maxy = ry;\r\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\r\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tconst hz = triangleBounds[ i + 5 ];\r\n\t\tconst lz = cz - hz;\r\n\t\tconst rz = cz + hz;\r\n\t\tif ( lz < minz ) minz = lz;\r\n\t\tif ( rz > maxz ) maxz = rz;\r\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\r\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\ttarget[ 0 ] = minx;\r\n\ttarget[ 1 ] = miny;\r\n\ttarget[ 2 ] = minz;\r\n\r\n\ttarget[ 3 ] = maxx;\r\n\ttarget[ 4 ] = maxy;\r\n\ttarget[ 5 ] = maxz;\r\n\r\n\tif ( includeCentroid ) {\r\n\r\n\t\tcentroidTarget[ 0 ] = cminx;\r\n\t\tcentroidTarget[ 1 ] = cminy;\r\n\t\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\t\tcentroidTarget[ 3 ] = cmaxx;\r\n\t\tcentroidTarget[ 4 ] = cmaxy;\r\n\t\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// A stand alone function for retrieving the centroid bounds.\r\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tif ( cx < cminx ) cminx = cx;\r\n\t\tif ( cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tif ( cy < cminy ) cminy = cy;\r\n\t\tif ( cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tif ( cz < cminz ) cminz = cz;\r\n\t\tif ( cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\tcentroidTarget[ 0 ] = cminx;\r\n\tcentroidTarget[ 1 ] = cminy;\r\n\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\tcentroidTarget[ 3 ] = cmaxx;\r\n\tcentroidTarget[ 4 ] = cmaxy;\r\n\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n}\r\n\r\n\r\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\r\n// will be on the left and elements on the right side of the split will be on the right. returns the index\r\n// of the first element on the right side, or offset + count if there are no elements on the right side.\r\nfunction partition( index, triangleBounds, offset, count, split ) {\r\n\r\n\tlet left = offset;\r\n\tlet right = offset + count - 1;\r\n\tconst pos = split.pos;\r\n\tconst axisOffset = split.axis * 2;\r\n\r\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\r\n\twhile ( true ) {\r\n\r\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\r\n\r\n\t\t\tleft ++;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\r\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\r\n\r\n\t\t\tright --;\r\n\r\n\t\t}\r\n\r\n\t\tif ( left < right ) {\r\n\r\n\t\t\t// we need to swap all of the information associated with the triangles at index\r\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\r\n\t\t\t// and perhaps the SAH planes\r\n\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tlet t0 = index[ left * 3 + i ];\r\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\r\n\t\t\t\tindex[ right * 3 + i ] = t0;\r\n\r\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\r\n\r\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tleft ++;\r\n\t\t\tright --;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn left;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst BIN_COUNT = 32;\r\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\r\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\r\n\r\n\treturn {\r\n\r\n\t\tcount: 0,\r\n\t\tbounds: new Float32Array( 6 ),\r\n\t\trightCacheBounds: new Float32Array( 6 ),\r\n\t\tleftCacheBounds: new Float32Array( 6 ),\r\n\t\tcandidate: 0,\r\n\r\n\t};\r\n\r\n} );\r\nconst leftBounds = new Float32Array( 6 );\r\n\r\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\r\n\r\n\tlet axis = - 1;\r\n\tlet pos = 0;\r\n\r\n\t// Center\r\n\tif ( strategy === CENTER ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === AVERAGE ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === SAH ) {\r\n\r\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\r\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\r\n\r\n\t\t// iterate over all axes\r\n\t\tconst cStart = offset * 6;\r\n\t\tconst cEnd = ( offset + count ) * 6;\r\n\t\tfor ( let a = 0; a < 3; a ++ ) {\r\n\r\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\r\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\r\n\t\t\tconst axisLength = axisRight - axisLeft;\r\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\r\n\r\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\r\n\t\t\t// the triangle positions because it will be faster.\r\n\t\t\tif ( count < BIN_COUNT / 4 ) {\r\n\r\n\t\t\t\t// initialize the bin candidates\r\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\r\n\t\t\t\ttruncatedBins.length = count;\r\n\r\n\t\t\t\t// set the candidates\r\n\t\t\t\tlet b = 0;\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ b ];\r\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tbin.count = 0;\r\n\r\n\t\t\t\t\tconst {\r\n\t\t\t\t\t\tbounds,\r\n\t\t\t\t\t\tleftCacheBounds,\r\n\t\t\t\t\t\trightCacheBounds,\r\n\t\t\t\t\t} = bin;\r\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\r\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\r\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t\tbounds[ d ] = Infinity;\r\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttruncatedBins.sort( binsSort );\r\n\r\n\t\t\t\t// remove redundant splits\r\n\t\t\t\tlet splitCount = count;\r\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\r\n\r\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\r\n\t\t\t\t\t\tsplitCount --;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\r\n\r\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\r\n\r\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\r\n\t\t\t\t\t\t\tbin.count ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// expand all the bounds\r\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\tconst leftCount = bin.count;\r\n\t\t\t\t\tconst rightCount = count - bin.count;\r\n\r\n\t\t\t\t\t// check the cost of this split\r\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\r\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\r\n\r\n\t\t\t\t\tlet leftProb = 0;\r\n\t\t\t\t\tif ( leftCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet rightProb = 0;\r\n\t\t\t\t\tif ( rightCount !== 0 ) {\r\n\r\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\r\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = a;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\t\t\t\t\t\tpos = bin.candidate;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset the bins\r\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tbin.count = 0;\r\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\r\n\r\n\t\t\t\t\tconst bounds = bin.bounds;\r\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\t\t\t\t\tbounds[ d ] = Infinity;\r\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterate over all center positions\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\r\n\r\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\r\n\r\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\r\n\t\t\t\t\t// considered to be on the right side of the split\r\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\r\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\r\n\r\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\r\n\t\t\t\t\tbin.count ++;\r\n\r\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\r\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\r\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\r\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\r\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet leftCount = 0;\r\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tconst binCount = bin.count;\r\n\t\t\t\t\tconst bounds = bin.bounds;\r\n\r\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\r\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\r\n\r\n\t\t\t\t\t// dont do anything with the bounds if the new bounds have no triangles\r\n\t\t\t\t\tif ( binCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tif ( leftCount === 0 ) {\r\n\r\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tleftCount += binCount;\r\n\r\n\t\t\t\t\t// check the cost of this split\r\n\t\t\t\t\tlet leftProb = 0;\r\n\t\t\t\t\tlet rightProb = 0;\r\n\r\n\t\t\t\t\tif ( leftCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst rightCount = count - leftCount;\r\n\t\t\t\t\tif ( rightCount !== 0 ) {\r\n\r\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\r\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = a;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\t\t\t\t\t\tpos = bin.candidate;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\r\n\r\n\t}\r\n\r\n\treturn { axis, pos };\r\n\r\n}\r\n\r\n// returns the average coordinate on the specified axis of the all the provided triangles\r\nfunction getAverage( triangleBounds, offset, count, axis ) {\r\n\r\n\tlet avg = 0;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\r\n\r\n\t}\r\n\r\n\treturn avg / count;\r\n\r\n}\r\n\r\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\r\n// result is an array of size tris.length * 6 where triangle i maps to a\r\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\r\n// representing the center and half-extent in each dimension of triangle i\r\nfunction computeTriangleBounds( geo, fullBounds ) {\r\n\r\n\tconst posAttr = geo.attributes.position;\r\n\tconst posArr = posAttr.array;\r\n\tconst index = geo.index.array;\r\n\tconst triCount = index.length / 3;\r\n\tconst triangleBounds = new Float32Array( triCount * 6 );\r\n\r\n\t// support for an interleaved position buffer\r\n\tconst bufferOffset = posAttr.offset || 0;\r\n\tlet stride = 3;\r\n\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tstride = posAttr.data.stride;\r\n\r\n\t}\r\n\r\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\r\n\r\n\t\tconst tri3 = tri * 3;\r\n\t\tconst tri6 = tri * 6;\r\n\t\tconst ai = index[ tri3 + 0 ] * stride + bufferOffset;\r\n\t\tconst bi = index[ tri3 + 1 ] * stride + bufferOffset;\r\n\t\tconst ci = index[ tri3 + 2 ] * stride + bufferOffset;\r\n\r\n\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\tconst a = posArr[ ai + el ];\r\n\t\t\tconst b = posArr[ bi + el ];\r\n\t\t\tconst c = posArr[ ci + el ];\r\n\r\n\t\t\tlet min = a;\r\n\t\t\tif ( b < min ) min = b;\r\n\t\t\tif ( c < min ) min = c;\r\n\r\n\t\t\tlet max = a;\r\n\t\t\tif ( b > max ) max = b;\r\n\t\t\tif ( c > max ) max = c;\r\n\r\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\r\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\r\n\t\t\t// worked with.\r\n\t\t\tconst halfExtents = ( max - min ) / 2;\r\n\t\t\tconst el2 = el * 2;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\r\n\r\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\r\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn triangleBounds;\r\n\r\n}\r\n\r\nexport function buildTree( geo, options ) {\r\n\r\n\tfunction triggerProgress( trianglesProcessed ) {\r\n\r\n\t\tif ( onProgress ) {\r\n\r\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\r\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\r\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\r\n\r\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\r\n\r\n\t\t\treachedMaxDepth = true;\r\n\t\t\tif ( verbose ) {\r\n\r\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\r\n\t\t\t\tconsole.warn( geo );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// early out if we've met our capacity\r\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\t// Find where to split the volume\r\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\r\n\t\tif ( split.axis === - 1 ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\r\n\r\n\t\t// create the two new child nodes\r\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnode.splitAxis = split.axis;\r\n\r\n\t\t\t// create the left child and compute its bounding box\r\n\t\t\tconst left = new MeshBVHNode();\r\n\t\t\tconst lstart = offset;\r\n\t\t\tconst lcount = splitOffset - offset;\r\n\t\t\tnode.left = left;\r\n\t\t\tleft.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t\t// repeat for right\r\n\t\t\tconst right = new MeshBVHNode();\r\n\t\t\tconst rstart = splitOffset;\r\n\t\t\tconst rcount = count - lcount;\r\n\t\t\tnode.right = right;\r\n\t\t\tright.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n\tensureIndex( geo, options );\r\n\r\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\r\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\r\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\r\n\tconst fullBounds = new Float32Array( 6 );\r\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\r\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\r\n\tconst indexArray = geo.index.array;\r\n\tconst maxDepth = options.maxDepth;\r\n\tconst verbose = options.verbose;\r\n\tconst maxLeafTris = options.maxLeafTris;\r\n\tconst strategy = options.strategy;\r\n\tconst onProgress = options.onProgress;\r\n\tconst totalTriangles = geo.index.count / 3;\r\n\tlet reachedMaxDepth = false;\r\n\r\n\tconst roots = [];\r\n\tconst ranges = getRootIndexRanges( geo );\r\n\r\n\tif ( ranges.length === 1 ) {\r\n\r\n\t\tconst range = ranges[ 0 ];\r\n\t\tconst root = new MeshBVHNode();\r\n\t\troot.boundingData = fullBounds;\r\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\r\n\r\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\troots.push( root );\r\n\r\n\t} else {\r\n\r\n\t\tfor ( let range of ranges ) {\r\n\r\n\t\t\tconst root = new MeshBVHNode();\r\n\t\t\troot.boundingData = new Float32Array( 6 );\r\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\r\n\r\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\t\troots.push( root );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn roots;\r\n\r\n}\r\n\r\nexport function buildPackedTree( geo, options ) {\r\n\r\n\t// boundingData  \t\t\t\t: 6 float32\r\n\t// right / offset \t\t\t\t: 1 uint32\r\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\r\n\tconst roots = buildTree( geo, options );\r\n\r\n\tlet float32Array;\r\n\tlet uint32Array;\r\n\tlet uint16Array;\r\n\tconst packedRoots = [];\r\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\tfor ( let i = 0; i < roots.length; i ++ ) {\r\n\r\n\t\tconst root = roots[ i ];\r\n\t\tlet nodeCount = countNodes( root );\r\n\r\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\r\n\t\tfloat32Array = new Float32Array( buffer );\r\n\t\tuint32Array = new Uint32Array( buffer );\r\n\t\tuint16Array = new Uint16Array( buffer );\r\n\t\tpopulateBuffer( 0, root );\r\n\t\tpackedRoots.push( buffer );\r\n\r\n\t}\r\n\r\n\treturn packedRoots;\r\n\r\n\tfunction countNodes( node ) {\r\n\r\n\t\tif ( node.count ) {\r\n\r\n\t\t\treturn 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction populateBuffer( byteOffset, node ) {\r\n\r\n\t\tconst stride4Offset = byteOffset / 4;\r\n\t\tconst stride2Offset = byteOffset / 2;\r\n\t\tconst isLeaf = ! ! node.count;\r\n\t\tconst boundingData = node.boundingData;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = node.offset;\r\n\t\t\tconst count = node.count;\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\r\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\r\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\r\n\t\t\treturn byteOffset + BYTES_PER_NODE;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = node.left;\r\n\t\t\tconst right = node.right;\r\n\t\t\tconst splitAxis = node.splitAxis;\r\n\r\n\t\t\tlet nextUnusedPointer;\r\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\r\n\r\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\r\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\r\n\r\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\r\n\t\t\treturn nextUnusedPointer;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { Vector3 } from 'three';\r\n\r\nexport class SeparatingAxisBounds {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.min = Infinity;\r\n\t\tthis.max = - Infinity;\r\n\r\n\t}\r\n\r\n\tsetFromPointsField( points, field ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = p[ field ];\r\n\t\t\tmin = val < min ? val : min;\r\n\t\t\tmax = val > max ? val : max;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tsetFromPoints( axis, points ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = axis.dot( p );\r\n\t\t\tmin = val < min ? val : min;\r\n\t\t\tmax = val > max ? val : max;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tisSeparated( other ) {\r\n\r\n\t\treturn this.min > other.max || other.min > this.max;\r\n\r\n\t}\r\n\r\n}\r\n\r\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\r\n\r\n\tconst p = new Vector3();\r\n\treturn function setFromBox( axis, box ) {\r\n\r\n\t\tconst boxMin = box.min;\r\n\t\tconst boxMax = box.max;\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\r\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\r\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\r\n\r\n\t\t\t\t\tconst val = axis.dot( p );\r\n\t\t\t\t\tmin = Math.min( val, min );\r\n\t\t\t\t\tmax = Math.max( val, max );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const areIntersecting = ( function () {\r\n\r\n\tconst cacheSatBounds = new SeparatingAxisBounds();\r\n\treturn function areIntersecting( shape1, shape2 ) {\r\n\r\n\t\tconst points1 = shape1.points;\r\n\t\tconst satAxes1 = shape1.satAxes;\r\n\t\tconst satBounds1 = shape1.satBounds;\r\n\r\n\t\tconst points2 = shape2.points;\r\n\t\tconst satAxes2 = shape2.satAxes;\r\n\t\tconst satBounds2 = shape2.satBounds;\r\n\r\n\t\t// check axes of the first shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check axes of the second shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\r\n\r\nexport const closestPointLineToLine = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\r\n\tconst dir1 = new Vector3();\r\n\tconst dir2 = new Vector3();\r\n\tconst v02 = new Vector3();\r\n\treturn function closestPointLineToLine( l1, l2, result ) {\r\n\r\n\t\tconst v0 = l1.start;\r\n\t\tconst v10 = dir1;\r\n\t\tconst v2 = l2.start;\r\n\t\tconst v32 = dir2;\r\n\r\n\t\tv02.subVectors( v0, v2 );\r\n\t\tdir1.subVectors( l1.end, l2.start );\r\n\t\tdir2.subVectors( l2.end, l2.start );\r\n\r\n\t\t// float d0232 = v02.Dot(v32);\r\n\t\tconst d0232 = v02.dot( v32 );\r\n\r\n\t\t// float d3210 = v32.Dot(v10);\r\n\t\tconst d3210 = v32.dot( v10 );\r\n\r\n\t\t// float d3232 = v32.Dot(v32);\r\n\t\tconst d3232 = v32.dot( v32 );\r\n\r\n\t\t// float d0210 = v02.Dot(v10);\r\n\t\tconst d0210 = v02.dot( v10 );\r\n\r\n\t\t// float d1010 = v10.Dot(v10);\r\n\t\tconst d1010 = v10.dot( v10 );\r\n\r\n\t\t// float denom = d1010*d3232 - d3210*d3210;\r\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\r\n\r\n\t\tlet d, d2;\r\n\t\tif ( denom !== 0 ) {\r\n\r\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\r\n\r\n\t\t} else {\r\n\r\n\t\t\td = 0;\r\n\r\n\t\t}\r\n\r\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\r\n\r\n\t\tresult.x = d;\r\n\t\tresult.y = d2;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const closestPointsSegmentToSegment = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\r\n\tconst paramResult = new Vector2();\r\n\tconst temp1 = new Vector3();\r\n\tconst temp2 = new Vector3();\r\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\r\n\r\n\t\tclosestPointLineToLine( l1, l2, paramResult );\r\n\r\n\t\tlet d = paramResult.x;\r\n\t\tlet d2 = paramResult.y;\r\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\tl1.at( d, target1 );\r\n\t\t\tl2.at( d2, target2 );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d >= 0 && d <= 1 ) {\r\n\r\n\t\t\t// Only d2 is out of bounds.\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tl2.at( 0, target2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl2.at( 1, target2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\t// Only d is out of bounds.\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tl1.at( 0, target1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl1.at( 1, target1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Both u and u2 are out of bounds.\r\n\t\t\tlet p;\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tp = l1.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp = l1.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet p2;\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tp2 = l2.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp2 = l2.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst closestPoint = temp1;\r\n\t\t\tconst closestPoint2 = temp2;\r\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\r\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\r\n\r\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\r\n\r\n\t\t\t\ttarget1.copy( closestPoint );\r\n\t\t\t\ttarget2.copy( p2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget1.copy( p );\r\n\t\t\t\ttarget2.copy( closestPoint2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nexport const sphereIntersectTriangle = ( function () {\r\n\r\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\r\n\tconst closestPointTemp = new Vector3();\r\n\tconst projectedPointTemp = new Vector3();\r\n\tconst planeTemp = new Plane();\r\n\tconst lineTemp = new Line3();\r\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\r\n\r\n\t\tconst { radius, center } = sphere;\r\n\t\tconst { a, b, c } = triangle;\r\n\r\n\t\t// phase 1\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = b;\r\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = b;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\t// phase 2\r\n\t\tconst plane = triangle.getPlane( planeTemp );\r\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\r\n\t\tif ( dp <= radius ) {\r\n\r\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\r\n\t\t\tconst cp = triangle.containsPoint( pp );\r\n\t\t\tif ( cp ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\r\n\r\nconst DIST_EPSILON = 1e-15;\r\nfunction isNearZero( value ) {\r\n\r\n\treturn Math.abs( value ) < DIST_EPSILON;\r\n\r\n}\r\n\r\nexport class ExtendedTriangle extends Triangle {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isExtendedTriangle = true;\r\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.points = [ this.a, this.b, this.c ];\r\n\t\tthis.sphere = new Sphere();\r\n\t\tthis.plane = new Plane();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn sphereIntersectTriangle( sphere, this );\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst a = this.a;\r\n\t\tconst b = this.b;\r\n\t\tconst c = this.c;\r\n\t\tconst points = this.points;\r\n\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst satBounds = this.satBounds;\r\n\r\n\t\tconst axis0 = satAxes[ 0 ];\r\n\t\tconst sab0 = satBounds[ 0 ];\r\n\t\tthis.getNormal( axis0 );\r\n\t\tsab0.setFromPoints( axis0, points );\r\n\r\n\t\tconst axis1 = satAxes[ 1 ];\r\n\t\tconst sab1 = satBounds[ 1 ];\r\n\t\taxis1.subVectors( a, b );\r\n\t\tsab1.setFromPoints( axis1, points );\r\n\r\n\t\tconst axis2 = satAxes[ 2 ];\r\n\t\tconst sab2 = satBounds[ 2 ];\r\n\t\taxis2.subVectors( b, c );\r\n\t\tsab2.setFromPoints( axis2, points );\r\n\r\n\t\tconst axis3 = satAxes[ 3 ];\r\n\t\tconst sab3 = satBounds[ 3 ];\r\n\t\taxis3.subVectors( c, a );\r\n\t\tsab3.setFromPoints( axis3, points );\r\n\r\n\t\tthis.sphere.setFromPoints( this.points );\r\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t}\r\n\r\n}\r\n\r\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\r\n\r\n\tconst point1 = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\tconst edge = new Line3();\r\n\r\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\r\n\r\n\t\tconst { start, end } = segment;\r\n\t\tconst points = this.points;\r\n\t\tlet distSq;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check the triangle edges\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst nexti = ( i + 1 ) % 3;\r\n\t\t\tedge.start.copy( points[ i ] );\r\n\t\t\tedge.end.copy( points[ nexti ] );\r\n\r\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\r\n\r\n\t\t\tdistSq = point1.distanceToSquared( point2 );\r\n\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check end points\r\n\t\tthis.closestPointToPoint( start, point1 );\r\n\t\tdistSq = start.distanceToSquared( point1 );\r\n\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\tclosestDistanceSq = distSq;\r\n\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\tif ( target2 ) target2.copy( start );\r\n\r\n\t\t}\r\n\r\n\t\tthis.closestPointToPoint( end, point1 );\r\n\t\tdistSq = end.distanceToSquared( point1 );\r\n\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\tclosestDistanceSq = distSq;\r\n\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\tif ( target2 ) target2.copy( end );\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri2 = new ExtendedTriangle();\r\n\tconst arr1 = new Array( 3 );\r\n\tconst arr2 = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\tconst dir1 = new Vector3();\r\n\tconst dir2 = new Vector3();\r\n\tconst tempDir = new Vector3();\r\n\tconst edge = new Line3();\r\n\tconst edge1 = new Line3();\r\n\tconst edge2 = new Line3();\r\n\r\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\r\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\r\n\treturn function intersectsTriangle( other, target = null ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! other.isExtendedTriangle ) {\r\n\r\n\t\t\tsaTri2.copy( other );\r\n\t\t\tsaTri2.update();\r\n\t\t\tother = saTri2;\r\n\r\n\t\t} else if ( other.needsUpdate ) {\r\n\r\n\t\t\tother.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst plane1 = this.plane;\r\n\t\tconst plane2 = other.plane;\r\n\r\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\r\n\r\n\t\t\t// perform separating axis intersection test only for coplanar triangles\r\n\t\t\tconst satBounds1 = this.satBounds;\r\n\t\t\tconst satAxes1 = this.satAxes;\r\n\t\t\tarr2[ 0 ] = other.a;\r\n\t\t\tarr2[ 1 ] = other.b;\r\n\t\t\tarr2[ 2 ] = other.c;\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\r\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst satBounds2 = other.satBounds;\r\n\t\t\tconst satAxes2 = other.satAxes;\r\n\t\t\tarr1[ 0 ] = this.a;\r\n\t\t\tarr1[ 1 ] = this.b;\r\n\t\t\tarr1[ 2 ] = this.c;\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\r\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check crossed axes\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sa1 = satAxes1[ i ];\r\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\r\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\r\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\r\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( target ) {\r\n\r\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\r\n\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\r\n\r\n\t\t\t\ttarget.start.set( 0, 0, 0 );\r\n\t\t\t\ttarget.end.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// find the edge that intersects the other triangle plane\r\n\t\t\tconst points1 = this.points;\r\n\t\t\tlet found1 = false;\r\n\t\t\tlet count1 = 0;\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tconst p = points1[ i ];\r\n\t\t\t\tconst pNext = points1[ ( i + 1 ) % 3 ];\r\n\r\n\t\t\t\tedge.start.copy( p );\r\n\t\t\t\tedge.end.copy( pNext );\r\n\t\t\t\tedge.delta( dir1 );\r\n\r\n\t\t\t\tconst targetPoint = found1 ? edge1.start : edge1.end;\r\n\t\t\t\tconst startIntersects = isNearZero( plane2.distanceToPoint( p ) );\r\n\t\t\t\tif ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {\r\n\r\n\t\t\t\t\t// if the edge lies on the plane then take the line\r\n\t\t\t\t\tedge1.copy( edge );\r\n\t\t\t\t\tcount1 = 2;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\r\n\t\t\t\tconst doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;\r\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\r\n\r\n\t\t\t\t\tcount1 ++;\r\n\t\t\t\t\tif ( found1 ) {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfound1 = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( count1 === 1 && this.containsPoint( edge1.start ) ) {\r\n\r\n\t\t\t\tif ( target ) {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge1.start );\r\n\t\t\t\t\ttarget.end.copy( edge1.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else if ( count1 !== 2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// find the other triangles edge that intersects this plane\r\n\t\t\tconst points2 = other.points;\r\n\t\t\tlet found2 = false;\r\n\t\t\tlet count2 = 0;\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tconst p = points2[ i ];\r\n\t\t\t\tconst pNext = points2[ ( i + 1 ) % 3 ];\r\n\r\n\t\t\t\tedge.start.copy( p );\r\n\t\t\t\tedge.end.copy( pNext );\r\n\t\t\t\tedge.delta( dir2 );\r\n\r\n\t\t\t\tconst targetPoint = found2 ? edge2.start : edge2.end;\r\n\t\t\t\tconst startIntersects = isNearZero( plane1.distanceToPoint( p ) );\r\n\t\t\t\tif ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {\r\n\r\n\t\t\t\t\t// if the edge lies on the plane then take the line\r\n\t\t\t\t\tedge2.copy( edge );\r\n\t\t\t\t\tcount2 = 2;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\r\n\t\t\t\tconst doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;\r\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\r\n\r\n\t\t\t\t\tcount2 ++;\r\n\t\t\t\t\tif ( found2 ) {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfound2 = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.start ) ) {\r\n\r\n\t\t\t\tif ( target ) {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge2.start );\r\n\t\t\t\t\ttarget.end.copy( edge2.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else if ( count2 !== 2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// find swap the second edge so both lines are running the same direction\r\n\t\t\tedge1.delta( dir1 );\r\n\t\t\tedge2.delta( dir2 );\r\n\r\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\r\n\r\n\t\t\t\tlet tmp = edge2.start;\r\n\t\t\t\tedge2.start = edge2.end;\r\n\t\t\t\tedge2.end = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if the edges are overlapping\r\n\t\t\tconst s1 = edge1.start.dot( dir1 );\r\n\t\t\tconst e1 = edge1.end.dot( dir1 );\r\n\t\t\tconst s2 = edge2.start.dot( dir1 );\r\n\t\t\tconst e2 = edge2.end.dot( dir1 );\r\n\t\t\tconst separated1 = e1 < s2;\r\n\t\t\tconst separated2 = s1 < e2;\r\n\r\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// assign the target output\r\n\t\t\tif ( target ) {\r\n\r\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\r\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge1.start );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge2.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\r\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\r\n\r\n\t\t\t\t\ttarget.end.copy( edge1.end );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttarget.end.copy( edge2.end );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nExtendedTriangle.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\r\n\r\n\tconst point = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\tconst cornerFields = [ 'a', 'b', 'c' ];\r\n\tconst line1 = new Line3();\r\n\tconst line2 = new Line3();\r\n\r\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\r\n\r\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\r\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\r\n\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\r\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check all point distances\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tlet dist;\r\n\t\t\tconst field = cornerFields[ i ];\r\n\t\t\tconst otherVec = other[ field ];\r\n\t\t\tthis.closestPointToPoint( otherVec, point );\r\n\r\n\t\t\tdist = otherVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tconst thisVec = this[ field ];\r\n\t\t\tother.closestPointToPoint( thisVec, point );\r\n\r\n\t\t\tdist = thisVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\r\n\t\t\t\tif ( target2 ) target2.copy( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst f11 = cornerFields[ i ];\r\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\r\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\r\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\r\n\r\n\t\t\t\tconst f21 = cornerFields[ i2 ];\r\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\r\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\r\n\r\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\r\n\r\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Box3, Vector3, Matrix4, Line3 } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\r\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\r\n\r\nexport class OrientedBox extends Box3 {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isOrientedBox = true;\r\n\t\tthis.matrix = new Matrix4();\r\n\t\tthis.invMatrix = new Matrix4();\r\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\r\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t}\r\n\r\n\tset( min, max, matrix ) {\r\n\r\n\t\tsuper.set( min, max );\r\n\t\tthis.matrix.copy( matrix );\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tsuper.copy( other );\r\n\t\tthis.matrix.copy( other.matrix );\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\nOrientedBox.prototype.update = ( function () {\r\n\r\n\treturn function update() {\r\n\r\n\t\tconst matrix = this.matrix;\r\n\t\tconst min = this.min;\r\n\t\tconst max = this.max;\r\n\r\n\t\tconst points = this.points;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\r\n\t\t\t\t\tconst v = points[ i ];\r\n\t\t\t\t\tv.x = x ? max.x : min.x;\r\n\t\t\t\t\tv.y = y ? max.y : min.y;\r\n\t\t\t\t\tv.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tv.applyMatrix4( matrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst minVec = points[ 0 ];\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst index = 1 << i;\r\n\t\t\tconst pi = points[ index ];\r\n\r\n\t\t\taxis.subVectors( minVec, pi );\r\n\t\t\tsb.setFromPoints( axis, points );\r\n\r\n\t\t}\r\n\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\r\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\r\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\r\n\r\n\t\tthis.invMatrix.copy( this.matrix ).invert();\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsBox = ( function () {\r\n\r\n\tconst aabbBounds = new SeparatingAxisBounds();\r\n\treturn function intersectsBox( box ) {\r\n\r\n\t\t// TODO: should this be doing SAT against the AABB?\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\r\n\t\taabbBounds.min = min.x;\r\n\t\taabbBounds.max = max.x;\r\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.y;\r\n\t\taabbBounds.max = max.y;\r\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.z;\r\n\t\taabbBounds.max = max.z;\r\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\taabbBounds.setFromBox( axis, box );\r\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri = new ExtendedTriangle();\r\n\tconst pointsArr = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\treturn function intersectsTriangle( triangle ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! triangle.isExtendedTriangle ) {\r\n\r\n\t\t\tsaTri.copy( triangle );\r\n\t\t\tsaTri.update();\r\n\t\t\ttriangle = saTri;\r\n\r\n\t\t} else if ( triangle.needsUpdate ) {\r\n\r\n\t\t\ttriangle.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\r\n\t\tpointsArr[ 0 ] = triangle.a;\r\n\t\tpointsArr[ 1 ] = triangle.b;\r\n\t\tpointsArr[ 2 ] = triangle.c;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst sa = satAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\tconst triSatBounds = triangle.satBounds;\r\n\t\tconst triSatAxes = triangle.satAxes;\r\n\t\tconst points = this.points;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = triSatBounds[ i ];\r\n\t\t\tconst sa = triSatAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check crossed axes\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sa1 = satAxes[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\r\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\r\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\r\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.closestPointToPoint = ( function () {\r\n\r\n\treturn function closestPointToPoint( point, target1 ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\ttarget1\r\n\t\t\t.copy( point )\r\n\t\t\t.applyMatrix4( this.invMatrix )\r\n\t\t\t.clamp( this.min, this.max )\r\n\t\t\t.applyMatrix4( this.matrix );\r\n\r\n\t\treturn target1;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.distanceToBox = ( function () {\r\n\r\n\tconst xyzFields = [ 'x', 'y', 'z' ];\r\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\r\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\r\n\r\n\tconst point1 = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\r\n\t// early out if we find a value below threshold\r\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.intersectsBox( box ) ) {\r\n\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tbox.getCenter( point2 );\r\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\r\n\r\n\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tconst threshold2 = threshold * threshold;\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst points = this.points;\r\n\r\n\r\n\t\t// iterate over every edge and compare distances\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check over all these points\r\n\t\tfor ( let i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tpoint2.copy( p ).clamp( min, max );\r\n\r\n\t\t\tconst dist = p.distanceToSquared( point2 );\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( p );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate and check all line segment distances\r\n\t\tlet count = 0;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\r\n\r\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\r\n\r\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\r\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\r\n\r\n\t\t\t\t\t// get obb line segments\r\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst p1 = points[ index ];\r\n\t\t\t\t\tconst p2 = points[ index2 ];\r\n\t\t\t\t\tconst line1 = segments1[ count ];\r\n\t\t\t\t\tline1.set( p1, p2 );\r\n\r\n\r\n\t\t\t\t\t// get aabb line segments\r\n\t\t\t\t\tconst f1 = xyzFields[ i ];\r\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\r\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\r\n\t\t\t\t\tconst line2 = segments2[ count ];\r\n\t\t\t\t\tconst start = line2.start;\r\n\t\t\t\t\tconst end = line2.end;\r\n\r\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\r\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\r\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tcount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check all the other boxes point\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\r\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\r\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\r\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 12; i ++ ) {\r\n\r\n\t\t\tconst l1 = segments1[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\r\n\r\n\t\t\t\tconst l2 = segments2[ i2 ];\r\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\r\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n","\r\nimport { Vector2, Vector3, Triangle } from 'three';\r\n\r\n// sets the vertices of triangle `tri` with the 3 vertices after i\r\nexport function setTriangle( tri, i, index, pos ) {\r\n\r\n\tconst ta = tri.a;\r\n\tconst tb = tri.b;\r\n\tconst tc = tri.c;\r\n\r\n\tlet i0 = i;\r\n\tlet i1 = i + 1;\r\n\tlet i2 = i + 2;\r\n\tif ( index ) {\r\n\r\n\t\ti0 = index.getX( i );\r\n\t\ti1 = index.getX( i + 1 );\r\n\t\ti2 = index.getX( i + 2 );\r\n\r\n\t}\r\n\r\n\tta.x = pos.getX( i0 );\r\n\tta.y = pos.getY( i0 );\r\n\tta.z = pos.getZ( i0 );\r\n\r\n\ttb.x = pos.getX( i1 );\r\n\ttb.y = pos.getY( i1 );\r\n\ttb.z = pos.getZ( i1 );\r\n\r\n\ttc.x = pos.getX( i2 );\r\n\ttc.y = pos.getY( i2 );\r\n\ttc.z = pos.getZ( i2 );\r\n\r\n}\r\n\r\nexport function iterateOverTriangles(\r\n\toffset,\r\n\tcount,\r\n\tgeometry,\r\n\tintersectsTriangleFunc,\r\n\tcontained,\r\n\tdepth,\r\n\ttriangle\r\n) {\r\n\r\n\tconst index = geometry.index;\r\n\tconst pos = geometry.attributes.position;\r\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\r\n\r\n\t\tsetTriangle( triangle, i * 3, index, pos );\r\n\t\ttriangle.needsUpdate = true;\r\n\r\n\t\tif ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\nconst tempV1 = /* @__PURE__ */ new Vector3();\r\nconst tempV2 = /* @__PURE__ */ new Vector3();\r\nconst tempV3 = /* @__PURE__ */ new Vector3();\r\nconst tempUV1 = /* @__PURE__ */ new Vector2();\r\nconst tempUV2 = /* @__PURE__ */ new Vector2();\r\nconst tempUV3 = /* @__PURE__ */ new Vector2();\r\n\r\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\r\n\r\n\tconst indices = geometry.getIndex().array;\r\n\tconst positions = geometry.getAttribute( 'position' );\r\n\tconst uvs = geometry.getAttribute( 'uv' );\r\n\r\n\tconst a = indices[ triangleIndex * 3 ];\r\n\tconst b = indices[ triangleIndex * 3 + 1 ];\r\n\tconst c = indices[ triangleIndex * 3 + 2 ];\r\n\r\n\ttempV1.fromBufferAttribute( positions, a );\r\n\ttempV2.fromBufferAttribute( positions, b );\r\n\ttempV3.fromBufferAttribute( positions, c );\r\n\r\n\t// find the associated material index\r\n\tlet materialIndex = 0;\r\n\tconst groups = geometry.groups;\r\n\tconst firstVertexIndex = triangleIndex * 3;\r\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\t\tconst { start, count } = group;\r\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\r\n\r\n\t\t\tmaterialIndex = group.materialIndex;\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// extract uvs\r\n\tlet uv = null;\r\n\tif ( uvs ) {\r\n\r\n\t\ttempUV1.fromBufferAttribute( uvs, a );\r\n\t\ttempUV2.fromBufferAttribute( uvs, b );\r\n\t\ttempUV3.fromBufferAttribute( uvs, c );\r\n\r\n\t\tif ( target && target.uv ) uv = target.uv;\r\n\t\telse uv = new Vector2();\r\n\r\n\t\tTriangle.getUV( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\r\n\r\n\t}\r\n\r\n\t// adjust the provided target or create a new one\r\n\tif ( target ) {\r\n\r\n\t\tif ( ! target.face ) target.face = { };\r\n\t\ttarget.face.a = a;\r\n\t\ttarget.face.b = b;\r\n\t\ttarget.face.c = c;\r\n\t\ttarget.face.materialIndex = materialIndex;\r\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\r\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\r\n\r\n\t\tif ( ! target.uv ) target.uv = new Vector2();\r\n\t\ttarget.uv.copy( uv );\r\n\r\n\t\treturn target;\r\n\r\n\t} else {\r\n\r\n\t\treturn {\r\n\t\t\tface: {\r\n\t\t\t\ta: a,\r\n\t\t\t\tb: b,\r\n\t\t\t\tc: c,\r\n\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\r\n\t\t\t},\r\n\t\t\tuv: uv\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","export class PrimitivePool {\r\n\r\n\tconstructor( getNewPrimitive ) {\r\n\r\n\t\tthis._getNewPrimitive = getNewPrimitive;\r\n\t\tthis._primitives = [];\r\n\r\n\t}\r\n\r\n\tgetPrimitive() {\r\n\r\n\t\tconst primitives = this._primitives;\r\n\t\tif ( primitives.length === 0 ) {\r\n\r\n\t\t\treturn this._getNewPrimitive();\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn primitives.pop();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treleasePrimitive( primitive ) {\r\n\r\n\t\tthis._primitives.push( primitive );\r\n\r\n\t}\r\n\r\n}\r\n","export function IS_LEAF( n16, uint16Array ) {\r\n\r\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\r\n\r\n}\r\n\r\nexport function OFFSET( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 6 ];\r\n\r\n}\r\n\r\nexport function COUNT( n16, uint16Array ) {\r\n\r\n\treturn uint16Array[ n16 + 14 ];\r\n\r\n}\r\n\r\nexport function LEFT_NODE( n32 ) {\r\n\r\n\treturn n32 + 8;\r\n\r\n}\r\n\r\nexport function RIGHT_NODE( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 6 ];\r\n\r\n}\r\n\r\nexport function SPLIT_AXIS( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 7 ];\r\n\r\n}\r\n\r\nexport function BOUNDING_DATA_INDEX( n32 ) {\r\n\r\n\treturn n32;\r\n\r\n}\r\n","import { Box3, Vector3, Matrix4 } from 'three';\r\nimport { CONTAINED } from './Constants.js';\r\n\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\r\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\r\nimport { setTriangle } from '../utils/TriangleUtilities.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\r\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\r\n\r\nconst boundingBox = new Box3();\r\nconst boxIntersection = new Vector3();\r\nconst xyzFields = [ 'x', 'y', 'z' ];\r\n\r\nexport function raycast( nodeIndex32, geometry, side, ray, intersects ) {\r\n\r\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\tintersectTris( geometry, side, ray, offset, count, intersects );\r\n\r\n\t} else {\r\n\r\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\r\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\r\n\r\n\t\t\traycast( leftIndex, geometry, side, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\r\n\r\n\t\t\traycast( rightIndex, geometry, side, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function raycastFirst( nodeIndex32, geometry, side, ray ) {\r\n\r\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\r\n\r\n\t} else {\r\n\r\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\r\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\r\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\r\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\r\n\t\tconst rayDir = ray.direction[ xyzAxis ];\r\n\t\tconst leftToRight = rayDir >= 0;\r\n\r\n\t\t// c1 is the child to check first\r\n\t\tlet c1, c2;\r\n\t\tif ( leftToRight ) {\r\n\r\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\r\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\r\n\r\n\t\t}\r\n\r\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\r\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\r\n\r\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\r\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\r\n\t\tif ( c1Result ) {\r\n\r\n\t\t\t// check if the point is within the second bounds\r\n\t\t\t// \"point\" is in the local frame of the bvh\r\n\t\t\tconst point = c1Result.point[ xyzAxis ];\r\n\t\t\tconst isOutside = leftToRight ?\r\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\r\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\r\n\r\n\t\t\tif ( isOutside ) {\r\n\r\n\t\t\t\treturn c1Result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// either there was no intersection in the first node, or there could still be a closer\r\n\t\t// intersection in the second, so check the second node and then take the better of the two\r\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\r\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\r\n\r\n\t\tif ( c1Result && c2Result ) {\r\n\r\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn c1Result || c2Result || null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport const shapecast = ( function () {\r\n\r\n\tlet _box1, _box2;\r\n\tconst boxStack = [];\r\n\tconst boxPool = new PrimitivePool( () => new Box3() );\r\n\r\n\treturn function shapecast( ...args ) {\r\n\r\n\t\t_box1 = boxPool.getPrimitive();\r\n\t\t_box2 = boxPool.getPrimitive();\r\n\t\tboxStack.push( _box1, _box2 );\r\n\r\n\t\tconst result = shapecastTraverse( ...args );\r\n\r\n\t\tboxPool.releasePrimitive( _box1 );\r\n\t\tboxPool.releasePrimitive( _box2 );\r\n\t\tboxStack.pop();\r\n\t\tboxStack.pop();\r\n\r\n\t\tconst length = boxStack.length;\r\n\t\tif ( length > 0 ) {\r\n\r\n\t\t\t_box2 = boxStack[ length - 1 ];\r\n\t\t\t_box1 = boxStack[ length - 2 ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\tfunction shapecastTraverse(\r\n\t\tnodeIndex32,\r\n\t\tgeometry,\r\n\t\tintersectsBoundsFunc,\r\n\t\tintersectsRangeFunc,\r\n\t\tnodeScoreFunc = null,\r\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\r\n\t\tdepth = 0\r\n\t) {\r\n\r\n\t\t// Define these inside the function so it has access to the local variables needed\r\n\t\t// when converting to the buffer equivalents\r\n\t\tfunction getLeftOffset( nodeIndex32 ) {\r\n\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\r\n\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\t\t// adjust offset to point to the right node\r\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// return the end offset of the triangle range\r\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t}\r\n\r\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\r\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\r\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tlet c1 = left;\r\n\t\t\tlet c2 = right;\r\n\r\n\t\t\tlet score1, score2;\r\n\t\t\tlet box1, box2;\r\n\t\t\tif ( nodeScoreFunc ) {\r\n\r\n\t\t\t\tbox1 = _box1;\r\n\t\t\t\tbox2 = _box2;\r\n\r\n\t\t\t\t// bounding data is not offset\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\r\n\r\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\r\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\r\n\r\n\t\t\t\tif ( score2 < score1 ) {\r\n\r\n\t\t\t\t\tc1 = right;\r\n\t\t\t\t\tc2 = left;\r\n\r\n\t\t\t\t\tconst temp = score1;\r\n\t\t\t\t\tscore1 = score2;\r\n\t\t\t\t\tscore2 = temp;\r\n\r\n\t\t\t\t\tbox1 = box2;\r\n\t\t\t\t\t// box2 is always set before use below\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check box 1 intersection\r\n\t\t\tif ( ! box1 ) {\r\n\r\n\t\t\t\tbox1 = _box1;\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\r\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\r\n\r\n\t\t\tlet c1StopTraversal;\r\n\t\t\tif ( c1Intersection === CONTAINED ) {\r\n\r\n\t\t\t\tconst offset = getLeftOffset( c1 );\r\n\t\t\t\tconst end = getRightEndOffset( c1 );\r\n\t\t\t\tconst count = end - offset;\r\n\r\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc1StopTraversal =\r\n\t\t\t\t\tc1Intersection &&\r\n\t\t\t\t\tshapecastTraverse(\r\n\t\t\t\t\t\tc1,\r\n\t\t\t\t\t\tgeometry,\r\n\t\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\t\tdepth + 1\r\n\t\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c1StopTraversal ) return true;\r\n\r\n\t\t\t// Check box 2 intersection\r\n\t\t\t// cached box2 will have been overwritten by previous traversal\r\n\t\t\tbox2 = _box2;\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\r\n\r\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\r\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\r\n\r\n\t\t\tlet c2StopTraversal;\r\n\t\t\tif ( c2Intersection === CONTAINED ) {\r\n\r\n\t\t\t\tconst offset = getLeftOffset( c2 );\r\n\t\t\t\tconst end = getRightEndOffset( c2 );\r\n\t\t\t\tconst count = end - offset;\r\n\r\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc2StopTraversal =\r\n\t\t\t\t\tc2Intersection &&\r\n\t\t\t\t\tshapecastTraverse(\r\n\t\t\t\t\t\tc2,\r\n\t\t\t\t\t\tgeometry,\r\n\t\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\t\tdepth + 1\r\n\t\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c2StopTraversal ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} )();\r\n\r\nexport const intersectsGeometry = ( function () {\r\n\r\n\tconst triangle = new ExtendedTriangle();\r\n\tconst triangle2 = new ExtendedTriangle();\r\n\tconst invertedMat = new Matrix4();\r\n\r\n\tconst obb = new OrientedBox();\r\n\tconst obb2 = new OrientedBox();\r\n\r\n\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\r\n\r\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\tif ( cachedObb === null ) {\r\n\r\n\t\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\t\tcachedObb = obb;\r\n\r\n\t\t}\r\n\r\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst thisGeometry = geometry;\r\n\t\t\tconst thisIndex = thisGeometry.index;\r\n\t\t\tconst thisPos = thisGeometry.attributes.position;\r\n\r\n\t\t\tconst index = otherGeometry.index;\r\n\t\t\tconst pos = otherGeometry.attributes.position;\r\n\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\r\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\r\n\t\t\t// here.\r\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\r\n\r\n\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\r\n\t\t\t\tobb2.matrix.copy( invertedMat );\r\n\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\r\n\r\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\r\n\r\n\t\t\t\t\tintersectsTriangle: tri => {\r\n\r\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\treturn res;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\r\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\r\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = nodeIndex32 + 8;\r\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\r\n\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\r\n\t\t\tconst leftIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( leftIntersection ) return true;\r\n\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\r\n\t\t\tconst rightIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( rightIntersection ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nfunction intersectRay( nodeIndex32, array, ray, target ) {\r\n\r\n\tarrayToBox( nodeIndex32, array, boundingBox );\r\n\treturn ray.intersectBox( boundingBox, target );\r\n\r\n}\r\n\r\nconst bufferStack = [];\r\nlet _prevBuffer;\r\nlet _float32Array;\r\nlet _uint16Array;\r\nlet _uint32Array;\r\nexport function setBuffer( buffer ) {\r\n\r\n\tif ( _prevBuffer ) {\r\n\r\n\t\tbufferStack.push( _prevBuffer );\r\n\r\n\t}\r\n\r\n\t_prevBuffer = buffer;\r\n\t_float32Array = new Float32Array( buffer );\r\n\t_uint16Array = new Uint16Array( buffer );\r\n\t_uint32Array = new Uint32Array( buffer );\r\n\r\n}\r\n\r\nexport function clearBuffer() {\r\n\r\n\t_prevBuffer = null;\r\n\t_float32Array = null;\r\n\t_uint16Array = null;\r\n\t_uint32Array = null;\r\n\r\n\tif ( bufferStack.length ) {\r\n\r\n\t\tsetBuffer( bufferStack.pop() );\r\n\r\n\t}\r\n\r\n}\r\n","import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\r\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\r\nimport { buildPackedTree } from './buildFunctions.js';\r\nimport {\r\n\traycast,\r\n\traycastFirst,\r\n\tshapecast,\r\n\tintersectsGeometry,\r\n\tsetBuffer,\r\n\tclearBuffer,\r\n} from './castFunctions.js';\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\r\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\r\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\r\n\r\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\r\n\r\nconst aabb = /* @__PURE__ */ new Box3();\r\nconst aabb2 = /* @__PURE__ */ new Box3();\r\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst obb2 = /* @__PURE__ */ new OrientedBox();\r\nconst temp = /* @__PURE__ */ new Vector3();\r\nconst temp1 = /* @__PURE__ */ new Vector3();\r\nconst temp2 = /* @__PURE__ */ new Vector3();\r\nconst temp3 = /* @__PURE__ */ new Vector3();\r\nconst temp4 = /* @__PURE__ */ new Vector3();\r\nconst tempBox = /* @__PURE__ */ new Box3();\r\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\r\n\r\nexport class MeshBVH {\r\n\r\n\tstatic serialize( bvh, options = {} ) {\r\n\r\n\t\tif ( options.isBufferGeometry ) {\r\n\r\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\r\n\r\n\t\t\treturn MeshBVH.serialize(\r\n\t\t\t\targuments[ 0 ],\r\n\t\t\t\t{\r\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tcloneBuffers: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst geometry = bvh.geometry;\r\n\t\tconst rootData = bvh._roots;\r\n\t\tconst indexAttribute = geometry.getIndex();\r\n\t\tlet result;\r\n\t\tif ( options.cloneBuffers ) {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData.map( root => root.slice() ),\r\n\t\t\t\tindex: indexAttribute.array.slice(),\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData,\r\n\t\t\t\tindex: indexAttribute.array,\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tstatic deserialize( data, geometry, options = {} ) {\r\n\r\n\t\tif ( typeof options === 'boolean' ) {\r\n\r\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\r\n\r\n\t\t\treturn MeshBVH.deserialize(\r\n\t\t\t\targuments[ 0 ],\r\n\t\t\t\targuments[ 1 ],\r\n\t\t\t\t{\r\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tsetIndex: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst { index, roots } = data;\r\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\r\n\t\tbvh._roots = roots;\r\n\r\n\t\tif ( options.setIndex ) {\r\n\r\n\t\t\tconst indexAttribute = geometry.getIndex();\r\n\t\t\tif ( indexAttribute === null ) {\r\n\r\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\r\n\t\t\t\tgeometry.setIndex( newIndex );\r\n\r\n\t\t\t} else if ( indexAttribute.array !== index ) {\r\n\r\n\t\t\t\tindexAttribute.array.set( index );\r\n\t\t\t\tindexAttribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvh;\r\n\r\n\t}\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\tstrategy: CENTER,\r\n\t\t\tmaxDepth: 40,\r\n\t\t\tmaxLeafTris: 10,\r\n\t\t\tverbose: true,\r\n\t\t\tuseSharedArrayBuffer: false,\r\n\t\t\tsetBoundingBox: true,\r\n\t\t\tonProgress: null,\r\n\r\n\t\t\t// undocumented options\r\n\r\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\r\n\t\t\t[ SKIP_GENERATION ]: false,\r\n\r\n\t\t}, options );\r\n\r\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis._roots = null;\r\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\r\n\r\n\t\t\tthis._roots = buildPackedTree( geometry, options );\r\n\r\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\r\n\r\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// retain references to the geometry so we can use them it without having to\r\n\t\t// take a geometry reference in every function.\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\trefit( nodeIndices = null ) {\r\n\r\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst indexArr = geometry.index.array;\r\n\t\tconst posAttr = geometry.attributes.position;\r\n\t\tconst posArr = posAttr.array;\r\n\r\n\t\t// support for an interleaved position buffer\r\n\t\tconst bufferOffset = posAttr.offset || 0;\r\n\t\tlet stride = 3;\r\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tstride = posAttr.data.stride;\r\n\r\n\t\t}\r\n\r\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\t\tlet byteOffset = 0;\r\n\t\tconst roots = this._roots;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer = roots[ i ];\r\n\t\t\tuint32Array = new Uint32Array( buffer );\r\n\t\t\tuint16Array = new Uint16Array( buffer );\r\n\t\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t\t_traverse( 0, byteOffset );\r\n\t\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\t\tlet minx = Infinity;\r\n\t\t\t\tlet miny = Infinity;\r\n\t\t\t\tlet minz = Infinity;\r\n\t\t\t\tlet maxx = - Infinity;\r\n\t\t\t\tlet maxy = - Infinity;\r\n\t\t\t\tlet maxz = - Infinity;\r\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst index = indexArr[ i ] * stride + bufferOffset;\r\n\t\t\t\t\tconst x = posArr[ index + 0 ];\r\n\t\t\t\t\tconst y = posArr[ index + 1 ];\r\n\t\t\t\t\tconst z = posArr[ index + 2 ];\r\n\r\n\t\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + 8;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\t\tconst offsetRight = right + byteOffset;\r\n\t\t\t\tlet forceChildren = force;\r\n\t\t\t\tlet includesLeft = false;\r\n\t\t\t\tlet includesRight = false;\r\n\r\n\t\t\t\tif ( nodeIndices ) {\r\n\r\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\r\n\t\t\t\t\t// then we assume that all children need to be updated.\r\n\t\t\t\t\tif ( ! forceChildren ) {\r\n\r\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\r\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\r\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tincludesLeft = true;\r\n\t\t\t\t\tincludesRight = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\r\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\r\n\r\n\t\t\t\tlet leftChange = false;\r\n\t\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rightChange = false;\r\n\t\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst didChange = leftChange || rightChange;\r\n\t\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn didChange;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttraverse( callback, rootIndex = 0 ) {\r\n\r\n\t\tconst buffer = this._roots[ rootIndex ];\r\n\t\tconst uint32Array = new Uint32Array( buffer );\r\n\t\tconst uint16Array = new Uint16Array( buffer );\r\n\t\t_traverse( 0 );\r\n\r\n\t\tfunction _traverse( node32Index, depth = 0 ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// TODO: use node functions here\r\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\r\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\r\n\r\n\t\t\t\tif ( ! stopTraversal ) {\r\n\r\n\t\t\t\t\t_traverse( left, depth + 1 );\r\n\t\t\t\t\t_traverse( right, depth + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Core Cast Functions */\r\n\traycast( ray, materialOrSide = FrontSide ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst intersects = [];\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\t\t\tconst startCount = intersects.length;\r\n\r\n\t\t\tsetBuffer( roots[ i ] );\r\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\r\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n\traycastFirst( ray, materialOrSide = FrontSide ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tlet closestResult = null;\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\r\n\t\t\tsetBuffer( roots[ i ] );\r\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\t\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet result = false;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tif ( callbacks instanceof Function ) {\r\n\r\n\t\t\tif ( _intersectsTriangleFunc ) {\r\n\r\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\r\n\t\t\t\t// indices here.\r\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\r\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\r\n\r\n\t\t\t\t\tconst i3 = index * 3;\r\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\r\n\r\n\t\t\t\t};\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcallbacks = {\r\n\r\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\r\n\t\t\t\tintersectsBounds: callbacks,\r\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\r\n\t\t\t\tintersectsRange: null,\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tlet {\r\n\t\t\tboundsTraverseOrder,\r\n\t\t\tintersectsBounds,\r\n\t\t\tintersectsRange,\r\n\t\t\tintersectsTriangle,\r\n\t\t} = callbacks;\r\n\r\n\t\tif ( intersectsRange && intersectsTriangle ) {\r\n\r\n\t\t\tconst originalIntersectsRange = intersectsRange;\r\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\r\n\r\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t};\r\n\r\n\t\t} else if ( ! intersectsRange ) {\r\n\r\n\t\t\tif ( intersectsTriangle ) {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\r\n\r\n\t\t\t\t\treturn contained;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet result = false;\r\n\t\tlet byteOffset = 0;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += root.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\r\n\r\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\r\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\r\n\r\n\t\tlet {\r\n\t\t\tintersectsRanges,\r\n\t\t\tintersectsTriangles,\r\n\t\t} = callbacks;\r\n\r\n\t\tconst indexAttr = this.geometry.index;\r\n\t\tconst positionAttr = this.geometry.attributes.position;\r\n\r\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\r\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\r\n\r\n\t\ttempMatrix.copy( matrixToLocal ).invert();\r\n\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tconst triangle2 = trianglePool.getPrimitive();\r\n\r\n\t\tif ( intersectsTriangles ) {\r\n\r\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\r\n\r\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\r\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\r\n\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( intersectsRanges ) {\r\n\r\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\r\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\totherBvh.getBoundingBox( aabb2 );\r\n\t\taabb2.applyMatrix4( matrixToLocal );\r\n\t\tconst result = this.shapecast( {\r\n\r\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\r\n\r\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\r\n\r\n\t\t\t\taabb.copy( box );\r\n\t\t\t\taabb.applyMatrix4( tempMatrix );\r\n\t\t\t\treturn otherBvh.shapecast( {\r\n\r\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\r\n\r\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\r\n\r\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\t\ttrianglePool.releasePrimitive( triangle2 );\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/* Derived Cast Functions */\r\n\tintersectsBox( box, boxToMesh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToMesh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst pos = geometry.attributes.position;\r\n\t\tconst index = geometry.index;\r\n\t\tconst otherPos = otherGeometry.attributes.position;\r\n\t\tconst otherIndex = otherGeometry.index;\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tconst triangle2 = trianglePool.getPrimitive();\r\n\r\n\t\tlet tempTarget1 = temp1;\r\n\t\tlet tempTargetDest1 = temp2;\r\n\t\tlet tempTarget2 = null;\r\n\t\tlet tempTargetDest2 = null;\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttempTarget2 = temp3;\r\n\t\t\ttempTargetDest2 = temp4;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tlet closestDistanceTriIndex = null;\r\n\t\tlet closestDistanceOtherTriIndex = null;\r\n\t\ttempMatrix.copy( geometryToBvh ).invert();\r\n\t\tobb2.matrix.copy( tempMatrix );\r\n\t\tthis.shapecast(\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\treturn obb.distanceToBox( box );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\r\n\r\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\r\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\r\n\t\t\t\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\r\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\r\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsRange: ( offset, count ) => {\r\n\r\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\r\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\r\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\r\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\r\n\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\r\n\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\r\n\r\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\r\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\r\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\r\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\t\ttrianglePool.releasePrimitive( triangle2 );\r\n\r\n\t\tif ( closestDistance === Infinity ) return null;\r\n\r\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\r\n\t\telse target1.point.copy( tempTargetDest1 );\r\n\t\ttarget1.distance = closestDistance,\r\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\r\n\t\t\telse target2.point.copy( tempTargetDest2 );\r\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\r\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\r\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\r\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\r\n\r\n\t\t}\r\n\r\n\t\treturn target1;\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\t// early out if under minThreshold\r\n\t\t// skip checking if over maxThreshold\r\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t\t// returns Infinity if no value found\r\n\t\tconst minThresholdSq = minThreshold * minThreshold;\r\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\t\tlet closestDistanceTriIndex = null;\r\n\t\tthis.shapecast(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\r\n\t\t\t\t\treturn temp.distanceToSquared( point );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\r\n\r\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\r\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\ttemp1.copy( temp );\r\n\t\t\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\tif ( closestDistanceSq === Infinity ) return null;\r\n\r\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\r\n\r\n\t\tif ( ! target.point ) target.point = temp1.clone();\r\n\t\telse target.point.copy( temp1 );\r\n\t\ttarget.distance = closestDistance,\r\n\t\ttarget.faceIndex = closestDistanceTriIndex;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\ttarget.makeEmpty();\r\n\r\n\t\tconst roots = this._roots;\r\n\t\troots.forEach( buffer => {\r\n\r\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\r\n\t\t\ttarget.union( tempBox );\r\n\r\n\t\t} );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Deprecation\r\nconst originalRaycast = MeshBVH.prototype.raycast;\r\nMeshBVH.prototype.raycast = function ( ...args ) {\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"raycast\" has changed. See docs for new signature.' );\r\n\t\tconst [\r\n\t\t\tmesh, raycaster, ray, intersects,\r\n\t\t] = args;\r\n\r\n\t\tconst results = originalRaycast.call( this, ray, mesh.material );\r\n\t\tresults.forEach( hit => {\r\n\r\n\t\t\thit = convertRaycastIntersect( hit, mesh, raycaster );\r\n\t\t\tif ( hit ) {\r\n\r\n\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn intersects;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalRaycast.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalRaycastFirst = MeshBVH.prototype.raycastFirst;\r\nMeshBVH.prototype.raycastFirst = function ( ...args ) {\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"raycastFirst\" has changed. See docs for new signature.' );\r\n\t\tconst [\r\n\t\t\tmesh, raycaster, ray,\r\n\t\t] = args;\r\n\r\n\t\treturn convertRaycastIntersect( originalRaycastFirst.call( this, ray, mesh.material ), mesh, raycaster );\r\n\r\n\t} else {\r\n\r\n\t\treturn originalRaycastFirst.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;\r\nMeshBVH.prototype.closestPointToPoint = function ( ...args ) {\r\n\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"closestPointToPoint\" has changed. See docs for new signature.' );\r\n\r\n\t\targs.unshift();\r\n\r\n\t\tconst target = args[ 1 ];\r\n\t\tconst result = {};\r\n\t\targs[ 1 ] = result;\r\n\r\n\t\toriginalClosestPointToPoint.apply( this, args );\r\n\r\n\t\tif ( target ) {\r\n\r\n\t\t\ttarget.copy( result.point );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.distance;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalClosestPointToPoint.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;\r\nMeshBVH.prototype.closestPointToGeometry = function ( ...args ) {\r\n\r\n\tconst target1 = args[ 2 ];\r\n\tconst target2 = args[ 3 ];\r\n\tif ( target1 && target1.isVector3 || target2 && target2.isVector3 ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"closestPointToGeometry\" has changed. See docs for new signature.' );\r\n\r\n\t\tconst result1 = {};\r\n\t\tconst result2 = {};\r\n\t\tconst geometryToBvh = args[ 1 ];\r\n\t\targs[ 2 ] = result1;\r\n\t\targs[ 3 ] = result2;\r\n\r\n\t\toriginalClosestPointToGeometry.apply( this, args );\r\n\r\n\t\tif ( target1 ) {\r\n\r\n\t\t\ttarget1.copy( result1.point );\r\n\r\n\t\t}\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttarget2.copy( result2.point ).applyMatrix4( geometryToBvh );\r\n\r\n\t\t}\r\n\r\n\t\treturn result1.distance;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalClosestPointToGeometry.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalRefit = MeshBVH.prototype.refit;\r\nMeshBVH.prototype.refit = function ( ...args ) {\r\n\r\n\tconst nodeIndices = args[ 0 ];\r\n\tconst terminationIndices = args[ 1 ];\r\n\tif ( terminationIndices && ( terminationIndices instanceof Set || Array.isArray( terminationIndices ) ) ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature for \"refit\" has changed. See docs for new signature.' );\r\n\r\n\t\tconst newNodeIndices = new Set();\r\n\t\tterminationIndices.forEach( v => newNodeIndices.add( v ) );\r\n\t\tif ( nodeIndices ) {\r\n\r\n\t\t\tnodeIndices.forEach( v => newNodeIndices.add( v ) );\r\n\r\n\t\t}\r\n\r\n\t\toriginalRefit.call( this, newNodeIndices );\r\n\r\n\t} else {\r\n\r\n\t\toriginalRefit.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\n[\r\n\t'intersectsGeometry',\r\n\t'shapecast',\r\n\t'intersectsBox',\r\n\t'intersectsSphere',\r\n].forEach( name => {\r\n\r\n\tconst originalFunc = MeshBVH.prototype[ name ];\r\n\tMeshBVH.prototype[ name ] = function ( ...args ) {\r\n\r\n\t\tif ( args[ 0 ] === null || args[ 0 ].isMesh ) {\r\n\r\n\t\t\targs.shift();\r\n\t\t\tconsole.warn( `MeshBVH: The function signature for \"${ name }\" has changed and no longer takes Mesh. See docs for new signature.` );\r\n\r\n\t\t}\r\n\r\n\t\treturn originalFunc.apply( this, args );\r\n\r\n\t};\r\n\r\n} );\r\n","import { Ray, Matrix4, Mesh } from 'three';\r\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\r\nimport { MeshBVH } from '../core/MeshBVH.js';\r\n\r\nconst ray = /* @__PURE__ */ new Ray();\r\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\r\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\r\n\r\nexport function acceleratedRaycast( raycaster, intersects ) {\r\n\r\n\tif ( this.geometry.boundsTree ) {\r\n\r\n\t\tif ( this.material === undefined ) return;\r\n\r\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\r\n\r\n\t\tconst bvh = this.geometry.boundsTree;\r\n\t\tif ( raycaster.firstHitOnly === true ) {\r\n\r\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\r\n\t\t\tif ( hit ) {\r\n\r\n\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst hits = bvh.raycast( ray, this.material );\r\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\r\n\t\t\t\tif ( hit ) {\r\n\r\n\t\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function computeBoundsTree( options ) {\r\n\r\n\tthis.boundsTree = new MeshBVH( this, options );\r\n\treturn this.boundsTree;\r\n\r\n}\r\n\r\nexport function disposeBoundsTree() {\r\n\r\n\tthis.boundsTree = null;\r\n\r\n}\r\n","import * as React from 'react';\nimport { acceleratedRaycast, computeBoundsTree, disposeBoundsTree } from 'three-mesh-bvh';\n\nfunction useBVH(mesh, options) {\n  React.useEffect(() => {\n    if (mesh.current) {\n      mesh.current.raycast = acceleratedRaycast;\n      const geometry = mesh.current.geometry;\n      geometry.computeBoundsTree = computeBoundsTree;\n      geometry.disposeBoundsTree = disposeBoundsTree;\n      geometry.computeBoundsTree(options);\n      return () => {\n        if (geometry.boundsTree) {\n          geometry.disposeBoundsTree();\n        }\n      };\n    }\n  }, [mesh, options]);\n}\n\nexport { useBVH };\n","import { Frustum, Vector3 } from 'three';\n\n/**\n * This is a class to check whether objects are in a selection area in 3D space\n */\n\nconst SelectionBox = (() => {\n  const frustum = new Frustum();\n  const center = new Vector3();\n  const tmpPoint = new Vector3();\n  const vecNear = new Vector3();\n  const vecTopLeft = new Vector3();\n  const vecTopRight = new Vector3();\n  const vecDownRight = new Vector3();\n  const vecDownLeft = new Vector3();\n  const vecFarTopLeft = new Vector3();\n  const vecFarTopRight = new Vector3();\n  const vecFarDownRight = new Vector3();\n  const vecFarDownLeft = new Vector3();\n  const vectemp1 = new Vector3();\n  const vectemp2 = new Vector3();\n  const vectemp3 = new Vector3();\n\n  class SelectionBox {\n    constructor(camera, scene, deep) {\n      this.camera = camera;\n      this.scene = scene;\n      this.startPoint = new Vector3();\n      this.endPoint = new Vector3();\n      this.collection = [];\n      this.deep = deep || Number.MAX_VALUE;\n    }\n\n    select(startPoint, endPoint) {\n      this.startPoint = startPoint || this.startPoint;\n      this.endPoint = endPoint || this.endPoint;\n      this.collection = [];\n      this.updateFrustum(this.startPoint, this.endPoint);\n      this.searchChildInFrustum(frustum, this.scene);\n      return this.collection;\n    }\n\n    updateFrustum(startPoint, endPoint) {\n      startPoint = startPoint || this.startPoint;\n      endPoint = endPoint || this.endPoint; // Avoid invalid frustum\n\n      if (startPoint.x === endPoint.x) {\n        endPoint.x += Number.EPSILON;\n      }\n\n      if (startPoint.y === endPoint.y) {\n        endPoint.y += Number.EPSILON;\n      }\n\n      this.camera.updateProjectionMatrix();\n      this.camera.updateMatrixWorld();\n\n      if (this.camera.isPerspectiveCamera) {\n        tmpPoint.copy(startPoint);\n        tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n        tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n        endPoint.x = Math.max(startPoint.x, endPoint.x);\n        endPoint.y = Math.min(startPoint.y, endPoint.y);\n        vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n        vecTopLeft.copy(tmpPoint);\n        vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n        vecDownRight.copy(endPoint);\n        vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n        vecTopLeft.unproject(this.camera);\n        vecTopRight.unproject(this.camera);\n        vecDownRight.unproject(this.camera);\n        vecDownLeft.unproject(this.camera);\n        vectemp1.copy(vecTopLeft).sub(vecNear);\n        vectemp2.copy(vecTopRight).sub(vecNear);\n        vectemp3.copy(vecDownRight).sub(vecNear);\n        vectemp1.normalize();\n        vectemp2.normalize();\n        vectemp3.normalize();\n        vectemp1.multiplyScalar(this.deep);\n        vectemp2.multiplyScalar(this.deep);\n        vectemp3.multiplyScalar(this.deep);\n        vectemp1.add(vecNear);\n        vectemp2.add(vecNear);\n        vectemp3.add(vecNear);\n        var planes = frustum.planes;\n        planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n        planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n        planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n        planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n        planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n        planes[5].normal.multiplyScalar(-1);\n      } else if (this.camera.isOrthographicCamera) {\n        const left = Math.min(startPoint.x, endPoint.x);\n        const top = Math.max(startPoint.y, endPoint.y);\n        const right = Math.max(startPoint.x, endPoint.x);\n        const down = Math.min(startPoint.y, endPoint.y);\n        vecTopLeft.set(left, top, -1);\n        vecTopRight.set(right, top, -1);\n        vecDownRight.set(right, down, -1);\n        vecDownLeft.set(left, down, -1);\n        vecFarTopLeft.set(left, top, 1);\n        vecFarTopRight.set(right, top, 1);\n        vecFarDownRight.set(right, down, 1);\n        vecFarDownLeft.set(left, down, 1);\n        vecTopLeft.unproject(this.camera);\n        vecTopRight.unproject(this.camera);\n        vecDownRight.unproject(this.camera);\n        vecDownLeft.unproject(this.camera);\n        vecFarTopLeft.unproject(this.camera);\n        vecFarTopRight.unproject(this.camera);\n        vecFarDownRight.unproject(this.camera);\n        vecFarDownLeft.unproject(this.camera);\n        var planes = frustum.planes;\n        planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n        planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n        planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n        planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n        planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n        planes[5].normal.multiplyScalar(-1);\n      } else {\n        console.error('THREE.SelectionBox: Unsupported camera type.');\n      }\n    }\n\n    searchChildInFrustum(frustum, object) {\n      if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.material !== undefined) {\n          if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n          center.copy(object.geometry.boundingSphere.center);\n          center.applyMatrix4(object.matrixWorld);\n\n          if (frustum.containsPoint(center)) {\n            this.collection.push(object);\n          }\n        }\n      }\n\n      if (object.children.length > 0) {\n        for (let x = 0; x < object.children.length; x++) {\n          this.searchChildInFrustum(frustum, object.children[x]);\n        }\n      }\n    }\n\n  }\n\n  return SelectionBox;\n})();\n\nexport { SelectionBox };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { SelectionBox } from 'three-stdlib';\nimport { useThree } from '@react-three/fiber';\nimport shallow from 'zustand/shallow';\n\nconst context = /*#__PURE__*/React.createContext([]);\nfunction Select({\n  box,\n  multiple,\n  children,\n  onChange,\n  border = '1px solid #55aaff',\n  backgroundColor = 'rgba(75, 160, 255, 0.1)',\n  filter: customFilter = item => item,\n  ...props\n}) {\n  const {\n    setEvents,\n    camera,\n    raycaster,\n    gl,\n    controls,\n    size,\n    get\n  } = useThree();\n  const [hovered, hover] = React.useState(false);\n  const [active, dispatch] = React.useReducer((state, {\n    object,\n    shift\n  }) => {\n    if (object === undefined) return [];else if (Array.isArray(object)) return object;else if (!shift) return state[0] === object ? [] : [object];else if (state.includes(object)) return state.filter(o => o !== object);else return [object, ...state];\n  }, []);\n  React.useEffect(() => void (onChange == null ? void 0 : onChange(active)), [active]);\n  const onClick = React.useCallback(e => {\n    e.stopPropagation();\n    dispatch({\n      object: customFilter([e.object])[0],\n      shift: multiple && e.shiftKey\n    });\n  }, []);\n  const onPointerMissed = React.useCallback(e => !hovered && dispatch({}), [hovered]);\n  const ref = React.useRef(null);\n  React.useEffect(() => {\n    if (!box || !multiple) return;\n    const selBox = new SelectionBox(camera, ref.current);\n    const element = document.createElement('div');\n    element.style.pointerEvents = 'none';\n    element.style.border = border;\n    element.style.backgroundColor = backgroundColor;\n    element.style.position = 'fixed';\n    const startPoint = new THREE.Vector2();\n    const pointTopLeft = new THREE.Vector2();\n    const pointBottomRight = new THREE.Vector2();\n    const oldRaycasterEnabled = get().events.enabled;\n    const oldControlsEnabled = controls == null ? void 0 : controls.enabled;\n    let isDown = false;\n\n    function prepareRay(event, vec) {\n      const {\n        offsetX,\n        offsetY\n      } = event;\n      const {\n        width,\n        height\n      } = size;\n      vec.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);\n    }\n\n    function onSelectStart(event) {\n      var _gl$domElement$parent;\n\n      if (controls) controls.enabled = false;\n      setEvents({\n        enabled: false\n      });\n      isDown = true;\n      (_gl$domElement$parent = gl.domElement.parentElement) == null ? void 0 : _gl$domElement$parent.appendChild(element);\n      element.style.left = `${event.clientX}px`;\n      element.style.top = `${event.clientY}px`;\n      element.style.width = '0px';\n      element.style.height = '0px';\n      startPoint.x = event.clientX;\n      startPoint.y = event.clientY;\n    }\n\n    function onSelectMove(event) {\n      pointBottomRight.x = Math.max(startPoint.x, event.clientX);\n      pointBottomRight.y = Math.max(startPoint.y, event.clientY);\n      pointTopLeft.x = Math.min(startPoint.x, event.clientX);\n      pointTopLeft.y = Math.min(startPoint.y, event.clientY);\n      element.style.left = `${pointTopLeft.x}px`;\n      element.style.top = `${pointTopLeft.y}px`;\n      element.style.width = `${pointBottomRight.x - pointTopLeft.x}px`;\n      element.style.height = `${pointBottomRight.y - pointTopLeft.y}px`;\n    }\n\n    function onSelectOver() {\n      if (isDown) {\n        var _element$parentElemen;\n\n        if (controls) controls.enabled = oldControlsEnabled;\n        setEvents({\n          enabled: oldRaycasterEnabled\n        });\n        isDown = false;\n        (_element$parentElemen = element.parentElement) == null ? void 0 : _element$parentElemen.removeChild(element);\n      }\n    }\n\n    function pointerDown(event) {\n      if (event.shiftKey) {\n        onSelectStart(event);\n        prepareRay(event, selBox.startPoint);\n      }\n    }\n\n    let previous = [];\n\n    function pointerMove(event) {\n      if (isDown) {\n        onSelectMove(event);\n        prepareRay(event, selBox.endPoint);\n        const allSelected = selBox.select().sort(o => o.uuid).filter(o => o.isMesh);\n\n        if (!shallow(allSelected, previous)) {\n          previous = allSelected;\n          dispatch({\n            object: customFilter(allSelected)\n          });\n        }\n      }\n    }\n\n    function pointerUp(event) {\n      if (isDown) onSelectOver();\n    }\n\n    document.addEventListener('pointerdown', pointerDown, {\n      passive: true\n    });\n    document.addEventListener('pointermove', pointerMove, {\n      passive: true,\n      capture: true\n    });\n    document.addEventListener('pointerup', pointerUp, {\n      passive: true\n    });\n    return () => {\n      document.removeEventListener('pointerdown', pointerDown);\n      document.removeEventListener('pointermove', pointerMove);\n      document.removeEventListener('pointerup', pointerUp);\n    };\n  }, [size, raycaster, camera, controls, gl]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref,\n    onClick: onClick,\n    onPointerOver: () => hover(true),\n    onPointerOut: () => hover(false),\n    onPointerMissed: onPointerMissed\n  }, props), /*#__PURE__*/React.createElement(context.Provider, {\n    value: active\n  }, children));\n}\nfunction useSelect() {\n  return React.useContext(context);\n}\n\nexport { Select, useSelect };\n","import * as React from 'react';\n\nfunction useCursor(hovered, onPointerOver = 'pointer', onPointerOut = 'auto') {\n  React.useEffect(() => {\n    if (hovered) {\n      document.body.style.cursor = onPointerOver;\n      return () => void (document.body.style.cursor = onPointerOut);\n    }\n  }, [hovered]);\n}\n\nexport { useCursor };\n"],"names":["boundingBox","THREE","boundingBoxSize","BBAnchor","anchor","props","ref","React","parentRef","_ref$current","_ref$current$parent","current","parent","add","useFrame","setFromObject","getSize","position","set","x","y","z","_extends","vA","Vector3","vB","vC","uvA","Vector2","uvB","uvC","intersectionPoint","checkBufferGeometryIntersection","ray","uv","a","b","c","side","fromBufferAttribute","intersection","pA","pB","pC","point","BackSide","intersectTriangle","DoubleSide","distance","origin","distanceTo","clone","checkIntersection","Triangle","face","normal","materialIndex","faceIndex","intersectTri","geo","tri","intersections","triOffset","index","getX","attributes","push","convertRaycastIntersect","hit","object","raycaster","applyMatrix4","matrixWorld","near","far","TRIANGLE_INTERSECT_COST","BYTES_PER_NODE","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","Math","pow","MeshBVHNode","arrayToBox","nodeIndex32","array","target","min","max","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","Infinity","i","dist","copyBounds","source","unionBounds","aVal","bVal","d","d3","expandByTriangleBounds","startIndex","triangleBounds","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","getBounds","offset","count","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","end","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","partition","split","left","right","pos","axisOffset","axis","t0","t1","t2","BIN_COUNT","binsSort","candidate","sahBins","Array","fill","map","Float32Array","rightCacheBounds","leftCacheBounds","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","avg","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","truncatedBins","length","bin","sort","splitCount","bi","splice","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","console","warn","buildTree","options","triggerProgress","trianglesProcessed","onProgress","totalTriangles","splitNode","node","depth","reachedMaxDepth","maxDepth","verbose","maxLeafTris","boundingData","splitOffset","indexArray","splitAxis","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","vertexCount","BufferConstructor","useSharedArrayBuffer","SharedArrayBuffer","ArrayBuffer","Uint32Array","Uint16Array","setIndex","BufferAttribute","ensureIndex","fullBounds","posAttr","posArr","triCount","bufferOffset","stride","isInterleavedBufferAttribute","data","tri3","tri6","ai","ci","el","halfExtents","el2","abs","computeTriangleBounds","roots","ranges","groups","rangeBoundaries","Set","group","start","sortedBoundaries","from","values","getRootIndexRanges","range","root","getCentroidBounds","buildPackedTree","float32Array","uint32Array","uint16Array","packedRoots","nodeCount","countNodes","buffer","populateBuffer","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","Error","SeparatingAxisBounds","this","points","field","l","val","p","dot","other","prototype","setFromBox","box","boxMin","boxMax","cacheSatBounds","closestPointLineToLine","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","subVectors","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","temp1","temp2","target1","target2","p2","at","closestPointToPoint","closestPoint","closestPoint2","distanceToSquared","copy","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","plane","getPlane","distanceToPoint","pp","projectPoint","containsPoint","isNearZero","value","ExtendedTriangle","args","isExtendedTriangle","satAxes","satBounds","Sphere","needsUpdate","axis0","sab0","getNormal","setFromPoints","axis1","sab1","axis2","sab2","axis3","sab3","setFromNormalAndCoplanarPoint","closestPointToSegment","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","sqrt","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","tempDir","edge1","edge2","update","plane1","plane2","satBounds1","satAxes1","sb","sa","isSeparated","satBounds2","satAxes2","sa1","i2","sa2","crossVectors","points1","found1","count1","pNext","delta","targetPoint","startIntersects","doesIntersect","intersectLine","points2","found2","count2","tmp","s1","e1","s2","e2","separated1","separated2","distanceToTriangle","cornerFields","line1","line2","lineTarget","getCenter","otherVec","thisVec","f11","f12","f21","f22","OrientedBox","isOrientedBox","matrix","Matrix4","invMatrix","alignedSatBounds","Box3","setTriangle","ta","tb","tc","i0","i1","getY","getZ","iterateOverTriangles","geometry","intersectsTriangleFunc","contained","v","minVec","pi","setFromPointsField","invert","intersectsBox","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","clamp","distanceToBox","xyzFields","segments1","segments2","threshold","threshold2","nextIndex","nextIndex2","index2","p1","f1","f2","f3","PrimitivePool","getNewPrimitive","_getNewPrimitive","_primitives","primitives","pop","primitive","IS_LEAF","n16","OFFSET","n32","COUNT","LEFT_NODE","RIGHT_NODE","boxIntersection","raycast","intersects","nodeIndex16","_float32Array","_uint16Array","_uint32Array","intersectTris","leftIndex","intersectRay","rightIndex","raycastFirst","res","intersectClosestTri","c1","c2","SPLIT_AXIS","xyzAxis","leftToRight","direction","c1Result","c2Result","shapecast","_box1","_box2","boxStack","boxPool","getPrimitive","shapecastTraverse","releasePrimitive","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","getLeftOffset","getRightEndOffset","score1","score2","box1","box2","temp","c1StopTraversal","isC1Leaf","c1Intersection","c2StopTraversal","isC2Leaf","c2Intersection","intersectsGeometry","triangle2","invertedMat","obb","obb2","otherGeometry","geometryToBvh","cachedObb","computeBoundingBox","leftIntersection","rightIntersection","thisGeometry","thisIndex","thisPos","boundsTree","intersectsBounds","intersectBox","_prevBuffer","bufferStack","setBuffer","clearBuffer","SKIP_GENERATION","Symbol","aabb","aabb2","tempMatrix","temp3","temp4","tempBox","trianglePool","MeshBVH","isBufferGeometry","Object","assign","setBoundingBox","_roots","getBoundingBox","nodeIndices","isArray","indexArr","_traverse","byteLength","node32Index","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","callback","rootIndex","stopTraversal","materialOrSide","FrontSide","isMaterial","isArrayMaterial","materialSide","startCount","j","jl","closestResult","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","i3","boundsTraverseOrder","intersectsRange","originalIntersectsRange","nodeIndex","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","iterateOverDoubleTriangles","offset1","offset2","depth1","index1","depth2","originalIntersectsRanges","nodeIndex1","nodeIndex2","boxToMesh","intersectsSphere","minThreshold","maxThreshold","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","score","otherOffset","otherCount","sub","minThresholdSq","maxThresholdSq","triIndex","makeEmpty","forEach","union","bvh","serialize","arguments","cloneBuffers","undefined","rootData","indexAttribute","getIndex","slice","deserialize","newIndex","originalRaycast","isMesh","mesh","results","call","material","apply","originalRaycastFirst","originalClosestPointToPoint","unshift","originalClosestPointToGeometry","closestPointToGeometry","isVector3","result1","result2","originalRefit","refit","terminationIndices","newNodeIndices","name","originalFunc","shift","Ray","tmpInverseMatrix","origMeshRaycastFunc","Mesh","acceleratedRaycast","firstHitOnly","hits","computeBoundsTree","disposeBoundsTree","useBVH","SelectionBox","frustum","Frustum","tmpPoint","vecNear","vecTopLeft","vecTopRight","vecDownRight","vecDownLeft","vecFarTopLeft","vecFarTopRight","vecFarDownRight","vecFarDownLeft","vectemp1","vectemp2","vectemp3","camera","scene","deep","startPoint","endPoint","collection","Number","MAX_VALUE","updateFrustum","searchChildInFrustum","EPSILON","updateProjectionMatrix","updateMatrixWorld","isPerspectiveCamera","setFromMatrixPosition","unproject","normalize","multiplyScalar","planes","setFromCoplanarPoints","isOrthographicCamera","top","down","error","isLine","isPoints","boundingSphere","computeBoundingSphere","children","context","Select","multiple","onChange","border","backgroundColor","filter","customFilter","item","useThree","setEvents","gl","controls","size","get","hovered","hover","state","includes","o","active","dispatch","onClick","e","stopPropagation","shiftKey","onPointerMissed","selBox","element","document","createElement","style","pointerEvents","pointTopLeft","pointBottomRight","oldRaycasterEnabled","events","enabled","oldControlsEnabled","isDown","previous","addEventListener","pointerDown","passive","pointerMove","capture","pointerUp","removeEventListener","prepareRay","event","vec","offsetX","offsetY","width","height","_gl$domElement$parent","domElement","parentElement","appendChild","clientX","clientY","onSelectStart","onSelectMove","allSelected","select","uuid","shallow","_element$parentElemen","removeChild","onSelectOver","onPointerOver","onPointerOut","Provider","useCursor","body","cursor"],"sourceRoot":""}